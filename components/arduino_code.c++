#include <Arduino.h>
#include <WiFiManager.h>       // WiFi configuration portal library
#include <WebServer.h>        // Lightweight web server
#include <WebSocketsServer.h> // WebSocket server library
#include <ArduinoJson.h>      // JSON handling
#include <SD.h>               // SD card access
#include <SPI.h>              // SPI communication
#include "driver/twai.h"             // ESP32 TWAI (CAN) driver
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/queue.h"
#include "time.h"

// --- Static IP Configuration ---
IPAddress staticIP(192, 168, 137, 57);
IPAddress gateway(192, 168, 137, 1);
IPAddress subnet(255, 255, 255, 0);
IPAddress dns(8, 8, 8, 8);

// --- Custom SPI pins for SD Card ---
#define SPI1_SCK   36
#define SPI1_MISO  37
#define SPI1_MOSI  35
#define SPI1_SS    34

#define CAN_TX GPIO_NUM_43
#define CAN_RX GPIO_NUM_44

SPIClass spiSD(HSPI); // Create HSPI instance for SD card
WebServer server(80); // HTTP server on port 80
WiFiManager wm;       // WiFiManager instance
WebSocketsServer webSocket = WebSocketsServer(81); // WebSocket server on port 81

unsigned long lastSend = 0;
unsigned long lastWebSocketReady = 0;

File logFileTRC;
String logFolder = "/log";
String trcFilename;
uint32_t messageCounter = 1;
uint64_t startMicros = 0;

twai_message_t rxMsg;
TaskHandle_t canTaskHandle = NULL;
TaskHandle_t notifyTaskHandle = NULL;
portMUX_TYPE rxMsgMux = portMUX_INITIALIZER_UNLOCKED;

// --- Timestamped Filename Generator ---
String getTimestampFilename(const String& ext) {
  struct tm timeinfo;
  char buffer[64];

  // Try to get valid timestamp
  if (getLocalTime(&timeinfo)) {
    strftime(buffer, sizeof(buffer), "/log/%Y-%m-%d_%H-%M-%S", &timeinfo);
    return String(buffer) + ext;
  }

  // If timestamp failed, fall back to numbered log
  int counter = 0;
  String fallbackName;

  do {
    fallbackName = "/log/log_" + String(counter) + ext;
    counter++;
  } while (SD.exists(fallbackName));

  return fallbackName;
}

void writeTRCHeader() {
  time_t now;
  time(&now);
  struct tm timeinfo;
  localtime_r(&now, &timeinfo);

  char dateStr[64];
  strftime(dateStr, sizeof(dateStr), "%m-%d-%Y %H:%M:%S", &timeinfo);

  // Fake STARTTIME value or use epoch + fraction
  double startTime = (double)now / 86400.0 + 25569.0;  // Excel date serial format

  logFileTRC.println(";$FILEVERSION=1.1");
  logFileTRC.print(";$STARTTIME=");
  logFileTRC.println(String(startTime, 10));
  logFileTRC.println(";");
  logFileTRC.println(";   Start time: " + String(dateStr) + ".0");
  logFileTRC.println(";   Generated by PCAN-View v5.3.0.942");
  logFileTRC.println(";");
  logFileTRC.println(";   Message Number");
  logFileTRC.println(";   |         Time Offset (ms)");
  logFileTRC.println(";   |         |        Type");
  logFileTRC.println(";   |         |        |        ID (hex)");
  logFileTRC.println(";   |         |        |        |     Data Length");
  logFileTRC.println(";   |         |        |        |     |   Data Bytes (hex) ...");
  logFileTRC.println(";   |         |        |        |     |   |");
  logFileTRC.println(";---+--   ----+----  --+--  ----+---  +  -+ -- -- -- -- -- -- --");
  logFileTRC.flush();
}

// --- Create TRC Log File ---
bool createLogFileTRC() {
  if (!SD.exists(logFolder)) SD.mkdir(logFolder);
  trcFilename = getTimestampFilename(".trc");
  Serial.println("file name");
  Serial.println(trcFilename);
  logFileTRC = SD.open(trcFilename, FILE_WRITE);
  if (!logFileTRC) return false;
  writeTRCHeader();
  return true;
}

// --- Return appropriate MIME type for a file ---
String getContentType(String filename) {
  if (filename.endsWith(".html")) return "text/html";
  if (filename.endsWith(".css")) return "text/css";
  if (filename.endsWith(".js")) return "application/javascript";
  if (filename.endsWith(".json")) return "application/json";
  if (filename.endsWith(".ico")) return "image/x-icon";
  if (filename.endsWith(".jpg") || filename.endsWith(".jpeg")) return "image/jpeg";
  if (filename.endsWith(".png")) return "image/png";
  if (filename.endsWith(".svg")) return "image/svg+xml";
  return "text/plain";
}

// --- Serve static file from SD card ---
bool handleFileRead(String path) {
  if (path.endsWith("/")) path += "index.html";
  String fullPath = "/dashboard" + path;
  if (SD.exists(fullPath)) {
    File file = SD.open(fullPath);
    if (!file) return false;
    server.sendHeader("Cache-Control", "public,max-age=31536000");
    server.sendHeader("Access-Control-Allow-Origin", "*");
    server.streamFile(file, getContentType(path));
    file.close();
    return true;
  }
  return false;
}

// --- Fallback for undefined routes ---
void handleNotFound() {
  if (!handleFileRead(server.uri())) {
    server.send(404, "text/plain", "404: Not Found");
  }
}

// --- WebSocket event handler ---
void onWebSocketEvent(uint8_t num, WStype_t type, uint8_t *payload, size_t length) {
  switch (type) {
    case WStype_CONNECTED:
      Serial.printf("[WS] Client %u connected from %s\n", num, webSocket.remoteIP(num).toString().c_str());
      webSocket.sendTXT(num, "connected");
      lastWebSocketReady = millis();
      break;
    case WStype_DISCONNECTED:
      Serial.printf("[WS] Client %u disconnected\n", num);
      break;
    case WStype_TEXT:
      if (strcmp((char*)payload, "get_status") == 0)
        webSocket.sendTXT(num, "{\"status\":\"ok\"}");
      break;
  }
}

// --- Broadcast current CAN data as JSON via WebSocket ---
void notifyClients() {
  // Use a local copy of rxMsg to avoid holding the lock too long
  twai_message_t localMsg;

  portENTER_CRITICAL(&rxMsgMux);
  localMsg = rxMsg;  // safe copy
  portEXIT_CRITICAL(&rxMsgMux);

  // Create JSON message
  StaticJsonDocument<400> doc;
  doc["id"] = localMsg.identifier;
  doc["dlc"] = localMsg.data_length_code;

  JsonArray dataArray = doc.createNestedArray("data");
  for (int i = 0; i < localMsg.data_length_code; i++) {
    dataArray.add(localMsg.data[i]);
  }

  String json;
  serializeJson(doc, json);
  webSocket.broadcastTXT(json);
}


void canReceiveTask(void *param) {
  while (true) {
    twai_message_t tempMsg;
    if (twai_receive(&tempMsg, pdMS_TO_TICKS(5)) == ESP_OK) {
      if (startMicros == 0) {
      startMicros = esp_timer_get_time();
    }

    uint64_t nowMicros = esp_timer_get_time();
    float offsetMs = (nowMicros - startMicros) / 1000.0;

    char line[128];
    int len = snprintf(line, sizeof(line), "%6lu) %11.1f  Rx         %04X  %d  ",
                       messageCounter++, offsetMs,
                       tempMsg.identifier, tempMsg.data_length_code);

    for (int i = 0; i < tempMsg.data_length_code; i++) {
      len += snprintf(line + len, sizeof(line) - len, "%02X ", tempMsg.data[i]);
    }

    logFileTRC.println(line);
    logFileTRC.flush();

    // Update shared variable safely
      portENTER_CRITICAL(&rxMsgMux);
      rxMsg = tempMsg;
      portEXIT_CRITICAL(&rxMsgMux);
    }
    vTaskDelay(pdMS_TO_TICKS(1)); // Slight delay to avoid watchdog
  }
}

void notifyClientsTask(void *param) {
  while (true) {
    notifyClients(); // broadcast via WebSocket
    vTaskDelay(pdMS_TO_TICKS(1000));  // every 10 mili second
  }
}

// --- Setup WiFi, SD, Server ---
void setup() {
  Serial.begin(115200);
  wm.setSTAStaticIPConfig(staticIP, gateway, subnet, dns);

  if (!wm.autoConnect("ESP32_S3_WIFI", "Configwifi")) {
    Serial.println("WiFi Connect Failed");
    ESP.restart();
  }

  Serial.println("WiFi Connected: " + WiFi.localIP().toString());

  // Sync time for file naming (UTC+5:30)
  configTime(19800, 0, "pool.ntp.org", "time.nist.gov");

  spiSD.begin(SPI1_SCK, SPI1_MISO, SPI1_MOSI, SPI1_SS);
  if (!SD.begin(SPI1_SS, spiSD, 40000000)) return;
  Serial.println("âœ… SD Card Ready");

  server.onNotFound(handleNotFound);
  server.begin();
  webSocket.begin();
  webSocket.onEvent(onWebSocketEvent);

  if (!createLogFileTRC()) {
    Serial.println("TRC log creation failed");
    return;
  }
   // Configure and start TWAI (CAN)
  twai_general_config_t g_config = TWAI_GENERAL_CONFIG_DEFAULT(CAN_TX, CAN_RX, TWAI_MODE_NORMAL);
  twai_timing_config_t t_config = TWAI_TIMING_CONFIG_1MBITS();
  twai_filter_config_t f_config = TWAI_FILTER_CONFIG_ACCEPT_ALL();

  if (twai_driver_install(&g_config, &t_config, &f_config) == ESP_OK && twai_start() == ESP_OK) {
    Serial.println("TWAI started");
  } else {
    Serial.println("TWAI init failed");
  }
  delay(1000);
 // ðŸ“Œ Create CAN receive task (Core 0, higher priority)
  xTaskCreatePinnedToCore(
    canReceiveTask, "CAN Receive", 4096, NULL, 3, &canTaskHandle, 0);

  // ðŸ“¡ Create Notify task (Core 1, lower priority)
  xTaskCreatePinnedToCore(
    notifyClientsTask, "Notify Clients", 4096, NULL, 1, &notifyTaskHandle, 1);
}

// --- Main Loop ---
void loop() {
  server.handleClient();
  webSocket.loop();
}