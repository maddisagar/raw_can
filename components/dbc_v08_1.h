/**
 * @file dbc_v08_1.h
 *
 * @brief This header file was generated by cantools version 40.2.2 Thu Jul 10 19:18:04 2025.
 *
 * @copyright Copyright (c) 2018-2019 Erik Moqvist
 *
 * @par License
 * The MIT License (MIT)
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef DBC_V08_1_H
#define DBC_V08_1_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define DBC_V08_1_TDT009_B003_FRAME_ID (0x67bu)
#define DBC_V08_1_TDT008_B002_FRAME_ID (0x67au)
#define DBC_V08_1_TDT007_B001_STATUS_FRAME_ID (0x679u)
#define DBC_V08_1_TDTFS001_TYPE_FRAME_ID (0x04u)
#define DBC_V08_1_DT011_FOC008_PI_TUNING_FRAME_ID (0x619u)
#define DBC_V08_1_DTCP014_HILLHOLD_PI_FRAME_ID (0x5ebu)
#define DBC_V08_1_DTCP013_REGEN_PI_FRAME_ID (0x5eau)
#define DBC_V08_1_DTCP012_FW_PI_FRAME_ID (0x5e9u)
#define DBC_V08_1_DTCP011_DC_CLAMP_PI_FRAME_ID (0x5e8u)
#define DBC_V08_1_DTCP010_SPEED_PI_FRAME_ID (0x5e7u)
#define DBC_V08_1_DTCP009_IQ_PI_FRAME_ID (0x5e6u)
#define DBC_V08_1_DTCP008_ID_PI_FRAME_ID (0x5e5u)
#define DBC_V08_1_RTW014_HILLHOLD_PI_FRAME_ID (0x40eu)
#define DBC_V08_1_RTW013_REGEN_PI_FRAME_ID (0x40du)
#define DBC_V08_1_RTW012_FW_PI_FRAME_ID (0x40cu)
#define DBC_V08_1_RTW011_DC_CLAMP_PI_FRAME_ID (0x40bu)
#define DBC_V08_1_RTW010_SPEED_PI_FRAME_ID (0x40au)
#define DBC_V08_1_RTW009_IQ_PI_FRAME_ID (0x409u)
#define DBC_V08_1_RTW008_ID_PI_FRAME_ID (0x408u)
#define DBC_V08_1_TRTCC003_FRAME_ID (0x22u)
#define DBC_V08_1_TDTACK002_FRAME_ID (0x5d3u)
#define DBC_V08_1_TRTW002_FRAME_ID (0x26u)
#define DBC_V08_1_TRTW001_FRAME_ID (0x25u)
#define DBC_V08_1_DTCP005_FRAME_ID (0x5e2u)
#define DBC_V08_1_DTACK001_FRAME_ID (0x5dcu)
#define DBC_V08_1_RTCC004_FRAME_ID (0x13u)
#define DBC_V08_1_DTCP007_FRAME_ID (0x5e4u)
#define DBC_V08_1_RTW007_FRAME_ID (0x407u)
#define DBC_V08_1_RTCC003_FRAME_ID (0x12u)
#define DBC_V08_1_RTDT001_FRAME_ID (0x5c3u)
#define DBC_V08_1_DT009_B003_FRAME_ID (0x617u)
#define DBC_V08_1_RTW005_FRAME_ID (0x405u)
#define DBC_V08_1_RTCC002_FRAME_ID (0x11u)
#define DBC_V08_1_DTCP004_FRAME_ID (0x5e1u)
#define DBC_V08_1_RTW004_FRAME_ID (0x404u)
#define DBC_V08_1_DTCP003_FRAME_ID (0x5e0u)
#define DBC_V08_1_RTW003_FRAME_ID (0x403u)
#define DBC_V08_1_RTCC001_FRAME_ID (0x10u)
#define DBC_V08_1_DTFS001_TYPE_FRAME_ID (0x03u)
#define DBC_V08_1_DTCP002_FRAME_ID (0x5dfu)
#define DBC_V08_1_DTCP001_FRAME_ID (0x5deu)
#define DBC_V08_1_RTW002_FRAME_ID (0x402u)
#define DBC_V08_1_RTW001_FRAME_ID (0x401u)
#define DBC_V08_1_DT008_B002_FRAME_ID (0x616u)
#define DBC_V08_1_DT007_B001_STATUS_FRAME_ID (0x615u)
#define DBC_V08_1_DT006_FOC006_FRAME_ID (0x614u)
#define DBC_V08_1_DT005_FOC005_FRAME_ID (0x613u)
#define DBC_V08_1_DT004_FOC004_FRAME_ID (0x612u)
#define DBC_V08_1_DT003_FOC003_DC_CURRENT_MODULE_FRAME_ID (0x611u)
#define DBC_V08_1_DT002_FOC002_DQ_CURRENT_MEA_REF_FRAME_ID (0x610u)
#define DBC_V08_1_DT001_FOC001_SPEED_TORQUE_REF_FRAME_ID (0x60fu)

/* Frame lengths in bytes. */
#define DBC_V08_1_TDT009_B003_LENGTH (8u)
#define DBC_V08_1_TDT008_B002_LENGTH (8u)
#define DBC_V08_1_TDT007_B001_STATUS_LENGTH (8u)
#define DBC_V08_1_TDTFS001_TYPE_LENGTH (8u)
#define DBC_V08_1_DT011_FOC008_PI_TUNING_LENGTH (8u)
#define DBC_V08_1_DTCP014_HILLHOLD_PI_LENGTH (8u)
#define DBC_V08_1_DTCP013_REGEN_PI_LENGTH (8u)
#define DBC_V08_1_DTCP012_FW_PI_LENGTH (8u)
#define DBC_V08_1_DTCP011_DC_CLAMP_PI_LENGTH (8u)
#define DBC_V08_1_DTCP010_SPEED_PI_LENGTH (8u)
#define DBC_V08_1_DTCP009_IQ_PI_LENGTH (8u)
#define DBC_V08_1_DTCP008_ID_PI_LENGTH (8u)
#define DBC_V08_1_RTW014_HILLHOLD_PI_LENGTH (8u)
#define DBC_V08_1_RTW013_REGEN_PI_LENGTH (8u)
#define DBC_V08_1_RTW012_FW_PI_LENGTH (8u)
#define DBC_V08_1_RTW011_DC_CLAMP_PI_LENGTH (8u)
#define DBC_V08_1_RTW010_SPEED_PI_LENGTH (8u)
#define DBC_V08_1_RTW009_IQ_PI_LENGTH (8u)
#define DBC_V08_1_RTW008_ID_PI_LENGTH (8u)
#define DBC_V08_1_TRTCC003_LENGTH (8u)
#define DBC_V08_1_TDTACK002_LENGTH (8u)
#define DBC_V08_1_TRTW002_LENGTH (8u)
#define DBC_V08_1_TRTW001_LENGTH (8u)
#define DBC_V08_1_DTCP005_LENGTH (8u)
#define DBC_V08_1_DTACK001_LENGTH (8u)
#define DBC_V08_1_RTCC004_LENGTH (8u)
#define DBC_V08_1_DTCP007_LENGTH (8u)
#define DBC_V08_1_RTW007_LENGTH (8u)
#define DBC_V08_1_RTCC003_LENGTH (8u)
#define DBC_V08_1_RTDT001_LENGTH (8u)
#define DBC_V08_1_DT009_B003_LENGTH (8u)
#define DBC_V08_1_RTW005_LENGTH (8u)
#define DBC_V08_1_RTCC002_LENGTH (8u)
#define DBC_V08_1_DTCP004_LENGTH (8u)
#define DBC_V08_1_RTW004_LENGTH (8u)
#define DBC_V08_1_DTCP003_LENGTH (8u)
#define DBC_V08_1_RTW003_LENGTH (8u)
#define DBC_V08_1_RTCC001_LENGTH (8u)
#define DBC_V08_1_DTFS001_TYPE_LENGTH (8u)
#define DBC_V08_1_DTCP002_LENGTH (8u)
#define DBC_V08_1_DTCP001_LENGTH (8u)
#define DBC_V08_1_RTW002_LENGTH (8u)
#define DBC_V08_1_RTW001_LENGTH (8u)
#define DBC_V08_1_DT008_B002_LENGTH (8u)
#define DBC_V08_1_DT007_B001_STATUS_LENGTH (8u)
#define DBC_V08_1_DT006_FOC006_LENGTH (8u)
#define DBC_V08_1_DT005_FOC005_LENGTH (8u)
#define DBC_V08_1_DT004_FOC004_LENGTH (8u)
#define DBC_V08_1_DT003_FOC003_DC_CURRENT_MODULE_LENGTH (8u)
#define DBC_V08_1_DT002_FOC002_DQ_CURRENT_MEA_REF_LENGTH (8u)
#define DBC_V08_1_DT001_FOC001_SPEED_TORQUE_REF_LENGTH (8u)

/* Extended or standard frame types. */
#define DBC_V08_1_TDT009_B003_IS_EXTENDED (0)
#define DBC_V08_1_TDT008_B002_IS_EXTENDED (0)
#define DBC_V08_1_TDT007_B001_STATUS_IS_EXTENDED (0)
#define DBC_V08_1_TDTFS001_TYPE_IS_EXTENDED (0)
#define DBC_V08_1_DT011_FOC008_PI_TUNING_IS_EXTENDED (0)
#define DBC_V08_1_DTCP014_HILLHOLD_PI_IS_EXTENDED (0)
#define DBC_V08_1_DTCP013_REGEN_PI_IS_EXTENDED (0)
#define DBC_V08_1_DTCP012_FW_PI_IS_EXTENDED (0)
#define DBC_V08_1_DTCP011_DC_CLAMP_PI_IS_EXTENDED (0)
#define DBC_V08_1_DTCP010_SPEED_PI_IS_EXTENDED (0)
#define DBC_V08_1_DTCP009_IQ_PI_IS_EXTENDED (0)
#define DBC_V08_1_DTCP008_ID_PI_IS_EXTENDED (0)
#define DBC_V08_1_RTW014_HILLHOLD_PI_IS_EXTENDED (0)
#define DBC_V08_1_RTW013_REGEN_PI_IS_EXTENDED (0)
#define DBC_V08_1_RTW012_FW_PI_IS_EXTENDED (0)
#define DBC_V08_1_RTW011_DC_CLAMP_PI_IS_EXTENDED (0)
#define DBC_V08_1_RTW010_SPEED_PI_IS_EXTENDED (0)
#define DBC_V08_1_RTW009_IQ_PI_IS_EXTENDED (0)
#define DBC_V08_1_RTW008_ID_PI_IS_EXTENDED (0)
#define DBC_V08_1_TRTCC003_IS_EXTENDED (0)
#define DBC_V08_1_TDTACK002_IS_EXTENDED (0)
#define DBC_V08_1_TRTW002_IS_EXTENDED (0)
#define DBC_V08_1_TRTW001_IS_EXTENDED (0)
#define DBC_V08_1_DTCP005_IS_EXTENDED (0)
#define DBC_V08_1_DTACK001_IS_EXTENDED (0)
#define DBC_V08_1_RTCC004_IS_EXTENDED (0)
#define DBC_V08_1_DTCP007_IS_EXTENDED (0)
#define DBC_V08_1_RTW007_IS_EXTENDED (0)
#define DBC_V08_1_RTCC003_IS_EXTENDED (0)
#define DBC_V08_1_RTDT001_IS_EXTENDED (0)
#define DBC_V08_1_DT009_B003_IS_EXTENDED (0)
#define DBC_V08_1_RTW005_IS_EXTENDED (0)
#define DBC_V08_1_RTCC002_IS_EXTENDED (0)
#define DBC_V08_1_DTCP004_IS_EXTENDED (0)
#define DBC_V08_1_RTW004_IS_EXTENDED (0)
#define DBC_V08_1_DTCP003_IS_EXTENDED (0)
#define DBC_V08_1_RTW003_IS_EXTENDED (0)
#define DBC_V08_1_RTCC001_IS_EXTENDED (0)
#define DBC_V08_1_DTFS001_TYPE_IS_EXTENDED (0)
#define DBC_V08_1_DTCP002_IS_EXTENDED (0)
#define DBC_V08_1_DTCP001_IS_EXTENDED (0)
#define DBC_V08_1_RTW002_IS_EXTENDED (0)
#define DBC_V08_1_RTW001_IS_EXTENDED (0)
#define DBC_V08_1_DT008_B002_IS_EXTENDED (0)
#define DBC_V08_1_DT007_B001_STATUS_IS_EXTENDED (0)
#define DBC_V08_1_DT006_FOC006_IS_EXTENDED (0)
#define DBC_V08_1_DT005_FOC005_IS_EXTENDED (0)
#define DBC_V08_1_DT004_FOC004_IS_EXTENDED (0)
#define DBC_V08_1_DT003_FOC003_DC_CURRENT_MODULE_IS_EXTENDED (0)
#define DBC_V08_1_DT002_FOC002_DQ_CURRENT_MEA_REF_IS_EXTENDED (0)
#define DBC_V08_1_DT001_FOC001_SPEED_TORQUE_REF_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */


/* Signal choices. */


/* Frame Names. */
#define DBC_V08_1_TDT009_B003_NAME "TDT009_B003"
#define DBC_V08_1_TDT008_B002_NAME "TDT008_B002"
#define DBC_V08_1_TDT007_B001_STATUS_NAME "TDT007_B001_Status"
#define DBC_V08_1_TDTFS001_TYPE_NAME "TDTFS001_Type"
#define DBC_V08_1_DT011_FOC008_PI_TUNING_NAME "DT011_FOC008_PiTuning"
#define DBC_V08_1_DTCP014_HILLHOLD_PI_NAME "DTCP014_Hillhold_PI"
#define DBC_V08_1_DTCP013_REGEN_PI_NAME "DTCP013_Regen_PI"
#define DBC_V08_1_DTCP012_FW_PI_NAME "DTCP012_FW_PI"
#define DBC_V08_1_DTCP011_DC_CLAMP_PI_NAME "DTCP011_DCClamp_PI"
#define DBC_V08_1_DTCP010_SPEED_PI_NAME "DTCP010_Speed_PI"
#define DBC_V08_1_DTCP009_IQ_PI_NAME "DTCP009_Iq_PI"
#define DBC_V08_1_DTCP008_ID_PI_NAME "DTCP008_Id_PI"
#define DBC_V08_1_RTW014_HILLHOLD_PI_NAME "RTW014_Hillhold_PI"
#define DBC_V08_1_RTW013_REGEN_PI_NAME "RTW013_Regen_PI"
#define DBC_V08_1_RTW012_FW_PI_NAME "RTW012_FW_PI"
#define DBC_V08_1_RTW011_DC_CLAMP_PI_NAME "RTW011_DCClamp_PI"
#define DBC_V08_1_RTW010_SPEED_PI_NAME "RTW010_Speed_PI"
#define DBC_V08_1_RTW009_IQ_PI_NAME "RTW009_Iq_PI"
#define DBC_V08_1_RTW008_ID_PI_NAME "RTW008_Id_PI"
#define DBC_V08_1_TRTCC003_NAME "TRTCC003"
#define DBC_V08_1_TDTACK002_NAME "TDTACK002"
#define DBC_V08_1_TRTW002_NAME "TRTW002"
#define DBC_V08_1_TRTW001_NAME "TRTW001"
#define DBC_V08_1_DTCP005_NAME "DTCP005"
#define DBC_V08_1_DTACK001_NAME "DTACK001"
#define DBC_V08_1_RTCC004_NAME "RTCC004"
#define DBC_V08_1_DTCP007_NAME "DTCP007"
#define DBC_V08_1_RTW007_NAME "RTW007"
#define DBC_V08_1_RTCC003_NAME "RTCC003"
#define DBC_V08_1_RTDT001_NAME "RTDT001"
#define DBC_V08_1_DT009_B003_NAME "DT009_B003"
#define DBC_V08_1_RTW005_NAME "RTW005"
#define DBC_V08_1_RTCC002_NAME "RTCC002"
#define DBC_V08_1_DTCP004_NAME "DTCP004"
#define DBC_V08_1_RTW004_NAME "RTW004"
#define DBC_V08_1_DTCP003_NAME "DTCP003"
#define DBC_V08_1_RTW003_NAME "RTW003"
#define DBC_V08_1_RTCC001_NAME "RTCC001"
#define DBC_V08_1_DTFS001_TYPE_NAME "DTFS001_Type"
#define DBC_V08_1_DTCP002_NAME "DTCP002"
#define DBC_V08_1_DTCP001_NAME "DTCP001"
#define DBC_V08_1_RTW002_NAME "RTW002"
#define DBC_V08_1_RTW001_NAME "RTW001"
#define DBC_V08_1_DT008_B002_NAME "DT008_B002"
#define DBC_V08_1_DT007_B001_STATUS_NAME "DT007_B001_Status"
#define DBC_V08_1_DT006_FOC006_NAME "DT006_FOC006"
#define DBC_V08_1_DT005_FOC005_NAME "DT005_FOC005"
#define DBC_V08_1_DT004_FOC004_NAME "DT004_FOC004"
#define DBC_V08_1_DT003_FOC003_DC_CURRENT_MODULE_NAME "DT003_FOC003_DCCurrentModule"
#define DBC_V08_1_DT002_FOC002_DQ_CURRENT_MEA_REF_NAME "DT002_FOC002_DQCurrentMeaRef"
#define DBC_V08_1_DT001_FOC001_SPEED_TORQUE_REF_NAME "DT001_FOC001_SpeedTorqueRef"

/* Signal Names. */
#define DBC_V08_1_TDT009_B003_AC_CURR_MEA_RMS_NAME "AcCurrMeaRms"
#define DBC_V08_1_TDT009_B003_DC_CURR_ESTD_NAME "DcCurrEstd"
#define DBC_V08_1_TDT009_B003_DC_BUS_VOLT_NAME "DcBusVolt"
#define DBC_V08_1_TDT009_B003_MTR_SPD_NAME "MtrSpd"
#define DBC_V08_1_TDT009_B003_THROT_VOLT_NAME "ThrotVolt"
#define DBC_V08_1_TDT008_B002_CTRLR_TEMP1_NAME "CtrlrTemp1"
#define DBC_V08_1_TDT008_B002_CTRLR_TEMP2_NAME "CtrlrTemp2"
#define DBC_V08_1_TDT008_B002_CTRLR_TEMP_NAME "CtrlrTemp"
#define DBC_V08_1_TDT008_B002_MTR_TEMP_NAME "MtrTemp"
#define DBC_V08_1_TDT007_B001_STATUS_THROT_MODE_NAME "ThrotMode"
#define DBC_V08_1_TDT007_B001_STATUS_ECO_BOOST_NAME "EcoBoost"
#define DBC_V08_1_TDT007_B001_STATUS_LIMP_HOME_MODE_NAME "LimpHomeMode"
#define DBC_V08_1_TDT007_B001_STATUS_BRAKE_NAME "Brake"
#define DBC_V08_1_TDT007_B001_STATUS_FORWARD_NAME "Forward"
#define DBC_V08_1_TDT007_B001_STATUS_REVERSE_NAME "Reverse"
#define DBC_V08_1_TDT007_B001_STATUS_NEUTRAL_NAME "Neutral"
#define DBC_V08_1_TDT007_B001_STATUS_HILLHOLD_MODE_NAME "HillholdMode"
#define DBC_V08_1_TDT007_B001_STATUS_REGEN_MODE_NAME "RegenMode"
#define DBC_V08_1_TDT007_B001_STATUS_DCU_CONTROL_MODE_STATUS_NAME "DcuControlModeStatus"
#define DBC_V08_1_TDT007_B001_STATUS_ASC_MODE_NAME "AscMode"
#define DBC_V08_1_TDT007_B001_STATUS_SNSR_HEALTH_STATUS_NAME "SnsrHealthStatus"
#define DBC_V08_1_TDT007_B001_STATUS_SNSR_HEALTH_STATUS_DC_BUS_NAME "SnsrHealthStatusDcBus"
#define DBC_V08_1_TDT007_B001_STATUS_SNSR_HEALTH_STATUS12_V_NAME "SnsrHealthStatus12V"
#define DBC_V08_1_TDT007_B001_STATUS_SNSR_HEALTH_STATUS5_V_NAME "SnsrHealthStatus5V"
#define DBC_V08_1_TDT007_B001_STATUS_SNSR_HEALTH_STATUS_PH_B_CURR_NAME "SnsrHealthStatusPhBCurr"
#define DBC_V08_1_TDT007_B001_STATUS_SNSR_HEALTH_STATUS_PH_C_CURR_NAME "SnsrHealthStatusPhCCurr"
#define DBC_V08_1_TDT007_B001_STATUS_SNSR_HEALTH_STATUS_THROT1_NAME "SnsrHealthStatusThrot1"
#define DBC_V08_1_TDT007_B001_STATUS_SNSR_HEALTH_STATUS_THROT2_NAME "SnsrHealthStatusThrot2"
#define DBC_V08_1_TDT007_B001_STATUS_SNSR_HEALTH_STATUS_QEP_NAME "SnsrHealthStatusQep"
#define DBC_V08_1_TDT007_B001_STATUS_SNSR_HEALTH_STATUS_MTR_TEMP_NAME "SnsrHealthStatusMtrTemp"
#define DBC_V08_1_TDT007_B001_STATUS_SNSR_HEALTH_STATUS_CTLR_TEMP1_NAME "SnsrHealthStatusCtlrTemp1"
#define DBC_V08_1_TDT007_B001_STATUS_SNSR_HEALTH_STATUS_CTLR_TEMP2_NAME "SnsrHealthStatusCtlrTemp2"
#define DBC_V08_1_TDT007_B001_STATUS_PC_MODE_ENABLE_NAME "PcModeEnable"
#define DBC_V08_1_TDT007_B001_STATUS_START_STOP_NAME "StartStop"
#define DBC_V08_1_TDT007_B001_STATUS_IDLE_SHUTDOWN_NAME "IdleShutdown"
#define DBC_V08_1_TDTFS001_TYPE_CAN_ERR_NAME "CanErr"
#define DBC_V08_1_TDTFS001_TYPE_CTRLR_TEMP_CUTBACK_LMT_ERR_NAME "CtrlrTempCutbackLmtErr"
#define DBC_V08_1_TDTFS001_TYPE_CTRLR_TEMP_CUTOFF_LMT_ERR_NAME "CtrlrTempCutoffLmtErr"
#define DBC_V08_1_TDTFS001_TYPE_CTRLR_TEMP_SNSR_OC_FLT_NAME "CtrlrTempSnsrOcFlt"
#define DBC_V08_1_TDTFS001_TYPE_CTRLR_TEMP_SNSR_SC_FLT_NAME "CtrlrTempSnsrScFlt"
#define DBC_V08_1_TDTFS001_TYPE_DC_BUS_OV_ERR_NAME "DcBusOvErr"
#define DBC_V08_1_TDTFS001_TYPE_DC_BUS_SNSR_OC_FLT_NAME "DcBusSnsrOcFlt"
#define DBC_V08_1_TDTFS001_TYPE_DC_BUS_SNSR_SC_FLT_NAME "DcBusSnsrScFlt"
#define DBC_V08_1_TDTFS001_TYPE_DC_BUS_UV_ERR_NAME "DcBusUvErr"
#define DBC_V08_1_TDTFS001_TYPE_MTR_TEMP_CUTBACK_LMT_ERR_NAME "MtrTempCutbackLmtErr"
#define DBC_V08_1_TDTFS001_TYPE_MTR_TEMP_CUTOFF_LMT_ERR_NAME "MtrTempCutoffLmtErr"
#define DBC_V08_1_TDTFS001_TYPE_MTR_TEMP_SNSR_OC_FLT_NAME "MtrTempSnsrOcFlt"
#define DBC_V08_1_TDTFS001_TYPE_MTR_TEMP_SNSR_SC_FLT_NAME "MtrTempSnsrScFlt"
#define DBC_V08_1_TDTFS001_TYPE_PH_B_CURR_SNSR_OC_FLT_NAME "PhBCurrSnsrOcFlt"
#define DBC_V08_1_TDTFS001_TYPE_PH_B_CURR_SNSR_OVER_CURR_FLT_NAME "PhBCurrSnsrOverCurrFlt"
#define DBC_V08_1_TDTFS001_TYPE_PH_B_CURR_SNSR_SC_CURR_FLT_NAME "PhBCurrSnsrScCurrFlt"
#define DBC_V08_1_TDTFS001_TYPE_PH_B_CURR_SNSR_SC_FLT_NAME "PhBCurrSnsrScFlt"
#define DBC_V08_1_TDTFS001_TYPE_PH_C_CURR_SNSR_OC_FLT_NAME "PhCCurrSnsrOcFlt"
#define DBC_V08_1_TDTFS001_TYPE_PH_C_CURR_SNSR_OVER_CURR_FLT_NAME "PhCCurrSnsrOverCurrFlt"
#define DBC_V08_1_TDTFS001_TYPE_PH_C_CURR_SNSR_SC_CURR_FLT_NAME "PhCCurrSnsrScCurrFlt"
#define DBC_V08_1_TDTFS001_TYPE_PH_C_CURR_SNSR_SC_FLT_NAME "PhCCurrSnsrScFlt"
#define DBC_V08_1_TDTFS001_TYPE_QEP_FLT_NAME "QepFlt"
#define DBC_V08_1_TDTFS001_TYPE_SOC_LOW_LMT_ERR_NAME "SocLowLmtErr"
#define DBC_V08_1_TDTFS001_TYPE_THROT_LOW_LMT_ERR_NAME "ThrotLowLmtErr"
#define DBC_V08_1_TDTFS001_TYPE_THROT_REDUN_ERR_NAME "ThrotRedunErr"
#define DBC_V08_1_TDTFS001_TYPE_THROT_STUCK_ERR_NAME "ThrotStuckErr"
#define DBC_V08_1_TDTFS001_TYPE_THROT_UP_LMT_ERR_NAME "ThrotUpLmtErr"
#define DBC_V08_1_TDTFS001_TYPE_UNEXPECTED_PARK_SENSE_HIGH_ERR_NAME "UnexpectedParkSenseHighErr"
#define DBC_V08_1_TDTFS001_TYPE_UNINTENDED_ACCELERATION_ERR_NAME "UnintendedAccelerationErr"
#define DBC_V08_1_TDTFS001_TYPE_UNINTENDED_DECELERATION_ERR_NAME "UnintendedDecelerationErr"
#define DBC_V08_1_TDTFS001_TYPE_DC_BUS_LV_ERR_NAME "DcBusLvErr"
#define DBC_V08_1_TDTFS001_TYPE_THROT_SNSR_OC_FLT_NAME "ThrotSnsrOcFlt"
#define DBC_V08_1_TDTFS001_TYPE_THROT_SNSR_SC_FLT_NAME "ThrotSnsrScFlt"
#define DBC_V08_1_TDTFS001_TYPE_FNR_ERR_NAME "FnrErr"
#define DBC_V08_1_TDTFS001_TYPE_FNR_WARN_NAME "FnrWarn"
#define DBC_V08_1_TDTFS001_TYPE_SUPPLY12_SNSR_OC_FLT_NAME "Supply12SnsrOcFlt"
#define DBC_V08_1_TDTFS001_TYPE_SUPPLY5_SNSR_OC_FLT_NAME "Supply5SnsrOcFlt"
#define DBC_V08_1_TDTFS001_TYPE_SUPPLY12_UV_ERR_NAME "Supply12UvErr"
#define DBC_V08_1_TDTFS001_TYPE_SUPPLY5_UV_ERR_NAME "Supply5UvErr"
#define DBC_V08_1_TDTFS001_TYPE_HW_OVER_CURR_FLT_NAME "HwOverCurrFlt"
#define DBC_V08_1_TDTFS001_TYPE_TYPE_0_ERR_NAME "Type_0_Err"
#define DBC_V08_1_TDTFS001_TYPE_TYPE_1_ERR_NAME "Type_1_Err"
#define DBC_V08_1_TDTFS001_TYPE_TYPE_2_ERR_NAME "Type_2_Err"
#define DBC_V08_1_TDTFS001_TYPE_TYPE_3_ERR_NAME "Type_3_Err"
#define DBC_V08_1_TDTFS001_TYPE_TYPE_4_ERR_NAME "Type_4_Err"
#define DBC_V08_1_TDTFS001_TYPE_QEP_FLT_2_NAME "QepFlt_2"
#define DBC_V08_1_TDTFS001_TYPE_PH_A_CURR_SNSR_OVER_CURR_FLT_NAME "PhACurrSnsrOverCurrFlt"
#define DBC_V08_1_TDTFS001_TYPE_PH_A_CURR_SNSR_SC_CURR_FLT_NAME "PhACurrSnsrScCurrFlt"
#define DBC_V08_1_DT011_FOC008_PI_TUNING_DAXIS_FFWD_NAME "Daxis_FFWD"
#define DBC_V08_1_DT011_FOC008_PI_TUNING_DAXIS_PI_OUT_NAME "Daxis_PI_Out"
#define DBC_V08_1_DT011_FOC008_PI_TUNING_QAXIS_FFWD_NAME "Qaxis_FFWD"
#define DBC_V08_1_DT011_FOC008_PI_TUNING_QAXIS_PI_OUTPUT_NAME "Qaxis_PI_Output"
#define DBC_V08_1_DT011_FOC008_PI_TUNING_SPEED_PI_OUTPUT_NAME "Speed_PI_Output"
#define DBC_V08_1_DTCP014_HILLHOLD_PI_KI_HILLHOLD_NAME "Ki_Hillhold"
#define DBC_V08_1_DTCP014_HILLHOLD_PI_KP_HILLHOLD_NAME "Kp_Hillhold"
#define DBC_V08_1_DTCP013_REGEN_PI_KI_REGEN_NAME "Ki_Regen"
#define DBC_V08_1_DTCP013_REGEN_PI_KP_REGEN_NAME "Kp_Regen"
#define DBC_V08_1_DTCP012_FW_PI_KI_FW_NAME "Ki_FW"
#define DBC_V08_1_DTCP012_FW_PI_KP_FW_NAME "Kp_FW"
#define DBC_V08_1_DTCP011_DC_CLAMP_PI_KI_DC_CLAMPING_NAME "Ki_DCClamping"
#define DBC_V08_1_DTCP011_DC_CLAMP_PI_KP_DC_CLAMPING_NAME "Kp_DCClamping"
#define DBC_V08_1_DTCP010_SPEED_PI_KI_LOW_SPD_NAME "Ki_LowSpd"
#define DBC_V08_1_DTCP010_SPEED_PI_KI_HIGH_SPD_NAME "Ki_HighSpd"
#define DBC_V08_1_DTCP010_SPEED_PI_KP_LOW_SPD_NAME "Kp_LowSpd"
#define DBC_V08_1_DTCP010_SPEED_PI_KP_HIGH_SPD_NAME "Kp_HighSpd"
#define DBC_V08_1_DTCP009_IQ_PI_KI_IQ_NAME "Ki_Iq"
#define DBC_V08_1_DTCP009_IQ_PI_KP_IQ_NAME "Kp_Iq"
#define DBC_V08_1_DTCP008_ID_PI_KI_ID_NAME "Ki_Id"
#define DBC_V08_1_DTCP008_ID_PI_KP_ID_NAME "Kp_Id"
#define DBC_V08_1_RTW014_HILLHOLD_PI_KI_HILLHOLD_NAME "Ki_Hillhold"
#define DBC_V08_1_RTW014_HILLHOLD_PI_KP_HILLHOLD_NAME "Kp_Hillhold"
#define DBC_V08_1_RTW013_REGEN_PI_KI_REGEN_NAME "Ki_Regen"
#define DBC_V08_1_RTW013_REGEN_PI_KP_REGEN_NAME "Kp_Regen"
#define DBC_V08_1_RTW012_FW_PI_KI_FW_NAME "Ki_FW"
#define DBC_V08_1_RTW012_FW_PI_KP_FW_NAME "Kp_FW"
#define DBC_V08_1_RTW011_DC_CLAMP_PI_KI_DC_CLAMPING_NAME "Ki_DCClamping"
#define DBC_V08_1_RTW011_DC_CLAMP_PI_KP_DC_CLAMPING_NAME "Kp_DCClamping"
#define DBC_V08_1_RTW010_SPEED_PI_KI_LOW_SPD_NAME "Ki_LowSpd"
#define DBC_V08_1_RTW010_SPEED_PI_KI_HIGH_SPD_NAME "Ki_HighSpd"
#define DBC_V08_1_RTW010_SPEED_PI_KP_LOW_SPD_NAME "Kp_LowSpd"
#define DBC_V08_1_RTW010_SPEED_PI_KP_HIGH_SPD_NAME "Kp_HighSpd"
#define DBC_V08_1_RTW009_IQ_PI_KI_IQ_NAME "Ki_Iq"
#define DBC_V08_1_RTW009_IQ_PI_KP_IQ_NAME "Kp_Iq"
#define DBC_V08_1_RTW008_ID_PI_KI_ID_NAME "Ki_Id"
#define DBC_V08_1_RTW008_ID_PI_KP_ID_NAME "Kp_Id"
#define DBC_V08_1_TRTCC003_FLASH_CMD_NAME "FlashCmd"
#define DBC_V08_1_TRTCC003_START_STOP_NAME "StartStop"
#define DBC_V08_1_TRTCC003_FLASH_SAMPLE_NUMBER_NAME "FlashSampleNumber"
#define DBC_V08_1_TDTACK002_FLASH_STATUS_NAME "FlashStatus"
#define DBC_V08_1_TDTACK002_FLASH_ERR_ADDRESS_NAME "FlashErrAddress"
#define DBC_V08_1_TRTW002_SPD_TEST_CMD_MAX_NAME "SpdTestCmdMax"
#define DBC_V08_1_TRTW002_TRQ_TEST_CMD_MAX_NAME "TrqTestCmdMax"
#define DBC_V08_1_TRTW002_DRIVE_CYCLE_REPETITION_NUMBER_NAME "DriveCycleRepetitionNumber"
#define DBC_V08_1_TRTW001_SPD_TEST_CMD_FLASH_FACTOR_NAME "SpdTestCmdFlashFactor"
#define DBC_V08_1_TRTW001_TRQ_TEST_CMD_FLASH_FACTOR_NAME "TrqTestCmdFlashFactor"
#define DBC_V08_1_TRTW001_RELATIVE_TIME_NAME "RelativeTime"
#define DBC_V08_1_DTCP005_SPD_SLEWRATE_POSITIVE_NAME "SpdSlewratePositive"
#define DBC_V08_1_DTCP005_THROT_VOLT_SLEWRATE_POSITIVE_NAME "ThrotVoltSlewratePositive"
#define DBC_V08_1_DTCP005_SPD_SLEWRATE_NEGATIVE_NAME "SpdSlewrateNegative"
#define DBC_V08_1_DTCP005_THROT_VOLT_SLEWRATE_NEGATIVE_NAME "ThrotVoltSlewrateNegative"
#define DBC_V08_1_DTCP005_AUTOTUNING_OFFSET_ANGLE_NAME "AutotuningOffsetAngle"
#define DBC_V08_1_DTACK001_AUTOTUNING_OFFSET_ANGLE_NAME "AutotuningOffsetAngle"
#define DBC_V08_1_DTACK001_CONFIG_UPDATE_STATUS_NAME "ConfigUpdateStatus"
#define DBC_V08_1_DTACK001_AUTOTUNING_CONFIG_UPDATE_STATUS_NAME "AutotuningConfigUpdateStatus"
#define DBC_V08_1_RTCC004_PC_MODE_ENABLE_NAME "PcModeEnable"
#define DBC_V08_1_RTCC004_CONFIG_UPDATE_ENABLE_NAME "ConfigUpdateEnable"
#define DBC_V08_1_RTCC004_CONTROL_UPDATE_ENABLE_NAME "ControlUpdateEnable"
#define DBC_V08_1_RTCC004_USER_ACCESS_LEVEL_NAME "UserAccessLevel"
#define DBC_V08_1_DTCP007_SERIAL_NUMBER_NAME "SerialNumber"
#define DBC_V08_1_DTCP007_SW_VERSION_MAJOR_NAME "SW_Version_Major"
#define DBC_V08_1_DTCP007_SW_VERSION_MINOR_NAME "SW_Version_Minor"
#define DBC_V08_1_RTW007_SERIAL_NUMBER_NAME "SerialNumber"
#define DBC_V08_1_RTCC003_UPDATE_CONFIG_PARA_NAME "UpdateConfigPara"
#define DBC_V08_1_RTCC003_FETCH_CONFIG_PARA_NAME "FetchConfigPara"
#define DBC_V08_1_RTCC003_CC_PARA1_NAME "CCPara1"
#define DBC_V08_1_RTCC003_CC_PARA2_NAME "CCPara2"
#define DBC_V08_1_RTCC003_CC_PARA3_NAME "CCPara3"
#define DBC_V08_1_RTCC003_CC_PARA4_NAME "CCPara4"
#define DBC_V08_1_RTDT001_GUI_CONNECTION_NAME "GuiConnection"
#define DBC_V08_1_DT009_B003_AC_CURR_MEA_RMS_NAME "AcCurrMeaRms"
#define DBC_V08_1_DT009_B003_DC_CURR_ESTD_NAME "DcCurrEstd"
#define DBC_V08_1_DT009_B003_DC_BUS_VOLT_NAME "DcBusVolt"
#define DBC_V08_1_DT009_B003_MTR_SPD_NAME "MtrSpd"
#define DBC_V08_1_DT009_B003_THROT_VOLT_NAME "ThrotVolt"
#define DBC_V08_1_RTW005_SPD_SLEWRATE_POSITIVE_NAME "SpdSlewratePositive"
#define DBC_V08_1_RTW005_THROT_VOLT_SLEWRATE_POSITIVE_NAME "ThrotVoltSlewratePositive"
#define DBC_V08_1_RTW005_SPD_SLEWRATE_NEGATIVE_NAME "SpdSlewrateNegative"
#define DBC_V08_1_RTW005_THROT_VOLT_SLEWRATE_NEGATIVE_NAME "ThrotVoltSlewrateNegative"
#define DBC_V08_1_RTCC002_FWD_REV_NAME "FwdRev"
#define DBC_V08_1_RTCC002_ECO_BOOST_NAME "EcoBoost"
#define DBC_V08_1_RTCC002_SPD_PERCENTAGE_NAME "SpdPercentage"
#define DBC_V08_1_RTCC002_RUN_SPD_NAME "RunSpd"
#define DBC_V08_1_RTCC002_THROT_PERCENTAGE_NAME "ThrotPercentage"
#define DBC_V08_1_RTCC002_RUN_TRQ_NAME "RunTrq"
#define DBC_V08_1_DTCP004_THROT_TYPE_NAME "ThrotType"
#define DBC_V08_1_DTCP004_FNR_TYPE_NAME "FNRType"
#define DBC_V08_1_DTCP004_DIREC_OF_FWD_ROTATION_NAME "DirecOfFwdRotation"
#define DBC_V08_1_DTCP004_START_AVAIL_NAME "StartAvail"
#define DBC_V08_1_DTCP004_PARK_AVAIL_NAME "ParkAvail"
#define DBC_V08_1_DTCP004_CHARGER_AVAIL_NAME "ChargerAvail"
#define DBC_V08_1_DTCP004_CRUISE_AVAIL_NAME "CruiseAvail"
#define DBC_V08_1_DTCP004_KILL_AVAIL_NAME "KillAvail"
#define DBC_V08_1_DTCP004_ECO_BOOST_AVAIL_NAME "EcoBoostAvail"
#define DBC_V08_1_RTW004_THROT_TYPE_NAME "ThrotType"
#define DBC_V08_1_RTW004_FNR_TYPE_NAME "FNRType"
#define DBC_V08_1_RTW004_DIREC_OF_FWD_ROTATION_NAME "DirecOfFwdRotation"
#define DBC_V08_1_RTW004_START_AVAIL_NAME "StartAvail"
#define DBC_V08_1_RTW004_PARK_AVAIL_NAME "ParkAvail"
#define DBC_V08_1_RTW004_CHARGER_AVAIL_NAME "ChargerAvail"
#define DBC_V08_1_RTW004_CRUISE_AVAIL_NAME "CruiseAvail"
#define DBC_V08_1_RTW004_KILL_AVAIL_NAME "KillAvail"
#define DBC_V08_1_RTW004_ECO_BOOST_AVAIL_NAME "EcoBoostAvail"
#define DBC_V08_1_DTCP003_PWR_PEAK_ECO_NAME "PwrPeakEco"
#define DBC_V08_1_DTCP003_MTR_TEMP_CUTBACK_LMT_NAME "MtrTempCutbackLmt"
#define DBC_V08_1_DTCP003_MTR_TEMP_CUTOFF_LMT_NAME "MtrTempCutoffLmt"
#define DBC_V08_1_DTCP003_CTRLR_TEMP_CUTBACK_LMT_NAME "CtrlrTempCutbackLmt"
#define DBC_V08_1_DTCP003_CTRLR_TEMP_CUTOFF_LMT_NAME "CtrlrTempCutoffLmt"
#define DBC_V08_1_DTCP003_DCU_CONTROL_MODE_NAME "DcuControlMode"
#define DBC_V08_1_RTW003_PWR_PEAK_ECO_NAME "PwrPeakEco"
#define DBC_V08_1_RTW003_MTR_TEMP_CUTBACK_LMT_NAME "MtrTempCutbackLmt"
#define DBC_V08_1_RTW003_MTR_TEMP_CUTOFF_LMT_NAME "MtrTempCutoffLmt"
#define DBC_V08_1_RTW003_CTRLR_TEMP_CUTBACK_LMT_NAME "CtrlrTempCutbackLmt"
#define DBC_V08_1_RTW003_CTRLR_TEMP_CUTOFF_LMT_NAME "CtrlrTempCutoffLmt"
#define DBC_V08_1_RTW003_DCU_CONTROL_MODE_NAME "DcuControlMode"
#define DBC_V08_1_RTCC001_SNSR_HEALTH_TRIGG_NAME "SnsrHealthTrigg"
#define DBC_V08_1_RTCC001_START_STOP_NAME "StartStop"
#define DBC_V08_1_RTCC001_PARK_NAME "Park"
#define DBC_V08_1_RTCC001_CHARGER_NAME "Charger"
#define DBC_V08_1_RTCC001_CRUISE_NAME "Cruise"
#define DBC_V08_1_RTCC001_KILL_NAME "Kill"
#define DBC_V08_1_RTCC001_SW_RST_NAME "SwRst"
#define DBC_V08_1_RTCC001_AUTOTUNING_CMD_NAME "AutotuningCmd"
#define DBC_V08_1_DTFS001_TYPE_CAN_ERR_NAME "CanErr"
#define DBC_V08_1_DTFS001_TYPE_CTRLR_TEMP_CUTBACK_LMT_ERR_NAME "CtrlrTempCutbackLmtErr"
#define DBC_V08_1_DTFS001_TYPE_CTRLR_TEMP_CUTOFF_LMT_ERR_NAME "CtrlrTempCutoffLmtErr"
#define DBC_V08_1_DTFS001_TYPE_CTRLR_TEMP_SNSR_OC_FLT_NAME "CtrlrTempSnsrOcFlt"
#define DBC_V08_1_DTFS001_TYPE_CTRLR_TEMP_SNSR_SC_FLT_NAME "CtrlrTempSnsrScFlt"
#define DBC_V08_1_DTFS001_TYPE_DC_BUS_OV_ERR_NAME "DcBusOvErr"
#define DBC_V08_1_DTFS001_TYPE_DC_BUS_SNSR_OC_FLT_NAME "DcBusSnsrOcFlt"
#define DBC_V08_1_DTFS001_TYPE_DC_BUS_SNSR_SC_FLT_NAME "DcBusSnsrScFlt"
#define DBC_V08_1_DTFS001_TYPE_DC_BUS_UV_ERR_NAME "DcBusUvErr"
#define DBC_V08_1_DTFS001_TYPE_MTR_TEMP_CUTBACK_LMT_ERR_NAME "MtrTempCutbackLmtErr"
#define DBC_V08_1_DTFS001_TYPE_MTR_TEMP_CUTOFF_LMT_ERR_NAME "MtrTempCutoffLmtErr"
#define DBC_V08_1_DTFS001_TYPE_MTR_TEMP_SNSR_OC_FLT_NAME "MtrTempSnsrOcFlt"
#define DBC_V08_1_DTFS001_TYPE_MTR_TEMP_SNSR_SC_FLT_NAME "MtrTempSnsrScFlt"
#define DBC_V08_1_DTFS001_TYPE_PH_B_CURR_SNSR_OC_FLT_NAME "PhBCurrSnsrOcFlt"
#define DBC_V08_1_DTFS001_TYPE_PH_B_CURR_SNSR_OVER_CURR_FLT_NAME "PhBCurrSnsrOverCurrFlt"
#define DBC_V08_1_DTFS001_TYPE_PH_B_CURR_SNSR_SC_CURR_FLT_NAME "PhBCurrSnsrScCurrFlt"
#define DBC_V08_1_DTFS001_TYPE_PH_B_CURR_SNSR_SC_FLT_NAME "PhBCurrSnsrScFlt"
#define DBC_V08_1_DTFS001_TYPE_PH_C_CURR_SNSR_OC_FLT_NAME "PhCCurrSnsrOcFlt"
#define DBC_V08_1_DTFS001_TYPE_PH_C_CURR_SNSR_OVER_CURR_FLT_NAME "PhCCurrSnsrOverCurrFlt"
#define DBC_V08_1_DTFS001_TYPE_PH_C_CURR_SNSR_SC_CURR_FLT_NAME "PhCCurrSnsrScCurrFlt"
#define DBC_V08_1_DTFS001_TYPE_PH_C_CURR_SNSR_SC_FLT_NAME "PhCCurrSnsrScFlt"
#define DBC_V08_1_DTFS001_TYPE_QEP_FLT_NAME "QepFlt"
#define DBC_V08_1_DTFS001_TYPE_SOC_LOW_LMT_ERR_NAME "SocLowLmtErr"
#define DBC_V08_1_DTFS001_TYPE_THROT_LOW_LMT_ERR_NAME "ThrotLowLmtErr"
#define DBC_V08_1_DTFS001_TYPE_THROT_REDUN_ERR_NAME "ThrotRedunErr"
#define DBC_V08_1_DTFS001_TYPE_THROT_STUCK_ERR_NAME "ThrotStuckErr"
#define DBC_V08_1_DTFS001_TYPE_THROT_UP_LMT_ERR_NAME "ThrotUpLmtErr"
#define DBC_V08_1_DTFS001_TYPE_UNEXPECTED_PARK_SENSE_HIGH_ERR_NAME "UnexpectedParkSenseHighErr"
#define DBC_V08_1_DTFS001_TYPE_UNINTENDED_ACCELERATION_ERR_NAME "UnintendedAccelerationErr"
#define DBC_V08_1_DTFS001_TYPE_UNINTENDED_DECELERATION_ERR_NAME "UnintendedDecelerationErr"
#define DBC_V08_1_DTFS001_TYPE_DC_BUS_LV_ERR_NAME "DcBusLvErr"
#define DBC_V08_1_DTFS001_TYPE_THROT_SNSR_OC_FLT_NAME "ThrotSnsrOcFlt"
#define DBC_V08_1_DTFS001_TYPE_THROT_SNSR_SC_FLT_NAME "ThrotSnsrScFlt"
#define DBC_V08_1_DTFS001_TYPE_FNR_ERR_NAME "FnrErr"
#define DBC_V08_1_DTFS001_TYPE_FNR_WARN_NAME "FnrWarn"
#define DBC_V08_1_DTFS001_TYPE_SUPPLY12_SNSR_OC_FLT_NAME "Supply12SnsrOcFlt"
#define DBC_V08_1_DTFS001_TYPE_SUPPLY5_SNSR_OC_FLT_NAME "Supply5SnsrOcFlt"
#define DBC_V08_1_DTFS001_TYPE_SUPPLY12_UV_ERR_NAME "Supply12UvErr"
#define DBC_V08_1_DTFS001_TYPE_SUPPLY5_UV_ERR_NAME "Supply5UvErr"
#define DBC_V08_1_DTFS001_TYPE_HW_OVER_CURR_FLT_NAME "HwOverCurrFlt"
#define DBC_V08_1_DTFS001_TYPE_TYPE_0_ERR_NAME "Type_0_Err"
#define DBC_V08_1_DTFS001_TYPE_TYPE_1_ERR_NAME "Type_1_Err"
#define DBC_V08_1_DTFS001_TYPE_TYPE_2_ERR_NAME "Type_2_Err"
#define DBC_V08_1_DTFS001_TYPE_TYPE_3_ERR_NAME "Type_3_Err"
#define DBC_V08_1_DTFS001_TYPE_TYPE_4_ERR_NAME "Type_4_Err"
#define DBC_V08_1_DTFS001_TYPE_QEP_FLT_2_NAME "QepFlt_2"
#define DBC_V08_1_DTFS001_TYPE_PH_A_CURR_SNSR_OVER_CURR_FLT_NAME "PhACurrSnsrOverCurrFlt"
#define DBC_V08_1_DTFS001_TYPE_PH_A_CURR_SNSR_SC_CURR_FLT_NAME "PhACurrSnsrScCurrFlt"
#define DBC_V08_1_DTCP002_SPD_MAX_FWD_NAME "SpdMaxFwd"
#define DBC_V08_1_DTCP002_TRQ_MAX_NAME "TrqMax"
#define DBC_V08_1_DTCP002_SPD_MAX_REV_NAME "SpdMaxRev"
#define DBC_V08_1_DTCP002_THROT_LOW_LMT_NAME "ThrotLowLmt"
#define DBC_V08_1_DTCP002_THROT_UP_LMT_NAME "ThrotUpLmt"
#define DBC_V08_1_DTCP001_AC_CURR_MAX_RMS_NAME "AcCurrMaxRms"
#define DBC_V08_1_DTCP001_DC_CURR_MAX_NAME "DcCurrMax"
#define DBC_V08_1_DTCP001_OV_LMT_NAME "OvLmt"
#define DBC_V08_1_DTCP001_UV_LMT_NAME "UvLmt"
#define DBC_V08_1_DTCP001_REGEN_CURR_MAX_LMT_NAME "RegenCurrMaxLmt"
#define DBC_V08_1_RTW002_SPD_MAX_FWD_NAME "SpdMaxFwd"
#define DBC_V08_1_RTW002_TRQ_MAX_NAME "TrqMax"
#define DBC_V08_1_RTW002_SPD_MAX_REV_NAME "SpdMaxRev"
#define DBC_V08_1_RTW002_THROT_LOW_LMT_NAME "ThrotLowLmt"
#define DBC_V08_1_RTW002_THROT_UP_LMT_NAME "ThrotUpLmt"
#define DBC_V08_1_RTW001_AC_CURR_MAX_RMS_NAME "AcCurrMaxRms"
#define DBC_V08_1_RTW001_DC_CURR_MAX_NAME "DcCurrMax"
#define DBC_V08_1_RTW001_OV_LMT_NAME "OvLmt"
#define DBC_V08_1_RTW001_UV_LMT_NAME "UvLmt"
#define DBC_V08_1_RTW001_REGEN_CURR_MAX_LMT_NAME "RegenCurrMaxLmt"
#define DBC_V08_1_DT008_B002_CTRLR_TEMP1_NAME "CtrlrTemp1"
#define DBC_V08_1_DT008_B002_CTRLR_TEMP2_NAME "CtrlrTemp2"
#define DBC_V08_1_DT008_B002_CTRLR_TEMP_NAME "CtrlrTemp"
#define DBC_V08_1_DT008_B002_MTR_TEMP_NAME "MtrTemp"
#define DBC_V08_1_DT007_B001_STATUS_THROT_MODE_NAME "ThrotMode"
#define DBC_V08_1_DT007_B001_STATUS_ECO_BOOST_NAME "EcoBoost"
#define DBC_V08_1_DT007_B001_STATUS_LIMP_HOME_MODE_NAME "LimpHomeMode"
#define DBC_V08_1_DT007_B001_STATUS_BRAKE_NAME "Brake"
#define DBC_V08_1_DT007_B001_STATUS_FORWARD_NAME "Forward"
#define DBC_V08_1_DT007_B001_STATUS_REVERSE_NAME "Reverse"
#define DBC_V08_1_DT007_B001_STATUS_NEUTRAL_NAME "Neutral"
#define DBC_V08_1_DT007_B001_STATUS_HILLHOLD_MODE_NAME "HillholdMode"
#define DBC_V08_1_DT007_B001_STATUS_REGEN_MODE_NAME "RegenMode"
#define DBC_V08_1_DT007_B001_STATUS_DCU_CONTROL_MODE_STATUS_NAME "DcuControlModeStatus"
#define DBC_V08_1_DT007_B001_STATUS_ASC_MODE_NAME "AscMode"
#define DBC_V08_1_DT007_B001_STATUS_SNSR_HEALTH_STATUS_NAME "SnsrHealthStatus"
#define DBC_V08_1_DT007_B001_STATUS_SNSR_HEALTH_STATUS_DC_BUS_NAME "SnsrHealthStatusDcBus"
#define DBC_V08_1_DT007_B001_STATUS_SNSR_HEALTH_STATUS12_V_NAME "SnsrHealthStatus12V"
#define DBC_V08_1_DT007_B001_STATUS_SNSR_HEALTH_STATUS5_V_NAME "SnsrHealthStatus5V"
#define DBC_V08_1_DT007_B001_STATUS_SNSR_HEALTH_STATUS_PH_B_CURR_NAME "SnsrHealthStatusPhBCurr"
#define DBC_V08_1_DT007_B001_STATUS_SNSR_HEALTH_STATUS_PH_C_CURR_NAME "SnsrHealthStatusPhCCurr"
#define DBC_V08_1_DT007_B001_STATUS_SNSR_HEALTH_STATUS_THROT1_NAME "SnsrHealthStatusThrot1"
#define DBC_V08_1_DT007_B001_STATUS_SNSR_HEALTH_STATUS_THROT2_NAME "SnsrHealthStatusThrot2"
#define DBC_V08_1_DT007_B001_STATUS_SNSR_HEALTH_STATUS_QEP_NAME "SnsrHealthStatusQep"
#define DBC_V08_1_DT007_B001_STATUS_SNSR_HEALTH_STATUS_MTR_TEMP_NAME "SnsrHealthStatusMtrTemp"
#define DBC_V08_1_DT007_B001_STATUS_SNSR_HEALTH_STATUS_CTLR_TEMP1_NAME "SnsrHealthStatusCtlrTemp1"
#define DBC_V08_1_DT007_B001_STATUS_SNSR_HEALTH_STATUS_CTLR_TEMP2_NAME "SnsrHealthStatusCtlrTemp2"
#define DBC_V08_1_DT007_B001_STATUS_PC_MODE_ENABLE_NAME "PcModeEnable"
#define DBC_V08_1_DT007_B001_STATUS_START_STOP_NAME "StartStop"
#define DBC_V08_1_DT007_B001_STATUS_IDLE_SHUTDOWN_NAME "IdleShutdown"
#define DBC_V08_1_DT006_FOC006_THROT_TRQ_NAME "ThrotTrq"
#define DBC_V08_1_DT006_FOC006_FW_ERR_NAME "FwErr"
#define DBC_V08_1_DT006_FOC006_SPD_ERR_NAME "SpdErr"
#define DBC_V08_1_DT006_FOC006_POS_ERR_NAME "PosErr"
#define DBC_V08_1_DT005_FOC005_DAXIS_CURR_ERR_NAME "DaxisCurrErr"
#define DBC_V08_1_DT005_FOC005_QAXIS_CURR_ERR_NAME "QaxisCurrErr"
#define DBC_V08_1_DT005_FOC005_DC_CURR_CLAMP_ERR_NAME "DcCurrClampErr"
#define DBC_V08_1_DT005_FOC005_MI_NAME "Mi"
#define DBC_V08_1_DT005_FOC005_DC_CLAMP_SPD_NAME "DcClampSpd"
#define DBC_V08_1_DT004_FOC004_PH_A_CURR_NAME "PhACurr"
#define DBC_V08_1_DT004_FOC004_PH_B_CURR_NAME "PhBCurr"
#define DBC_V08_1_DT004_FOC004_PH_C_CURR_NAME "PhCCurr"
#define DBC_V08_1_DT003_FOC003_DC_CURRENT_MODULE_DAXIS_CURR_MEA_NAME "DaxisCurrMea"
#define DBC_V08_1_DT003_FOC003_DC_CURRENT_MODULE_QAXIS_CURR_MEA_NAME "QaxisCurrMea"
#define DBC_V08_1_DT003_FOC003_DC_CURRENT_MODULE_DAXIS_VOLT_NAME "DaxisVolt"
#define DBC_V08_1_DT003_FOC003_DC_CURRENT_MODULE_QAXIS_VOLT_NAME "QaxisVolt"
#define DBC_V08_1_DT003_FOC003_DC_CURRENT_MODULE_DAXIS_CURR_FW_REF_NAME "DaxisCurrFwRef"
#define DBC_V08_1_DT002_FOC002_DQ_CURRENT_MEA_REF_DAXIS_CURR_REF_NAME "DaxisCurrRef"
#define DBC_V08_1_DT002_FOC002_DQ_CURRENT_MEA_REF_DAXIS_CURR_MEA_NAME "DaxisCurrMea"
#define DBC_V08_1_DT002_FOC002_DQ_CURRENT_MEA_REF_QAXIS_CURR_REF_NAME "QaxisCurrRef"
#define DBC_V08_1_DT002_FOC002_DQ_CURRENT_MEA_REF_QAXIS_CURR_MEA_NAME "QaxisCurrMea"
#define DBC_V08_1_DT001_FOC001_SPEED_TORQUE_REF_SPD_REF_NAME "SpdRef"
#define DBC_V08_1_DT001_FOC001_SPEED_TORQUE_REF_TRQ_REF_NAME "TrqRef"
#define DBC_V08_1_DT001_FOC001_SPEED_TORQUE_REF_DC_CLAMP_SPD_NAME "DcClampSpd"

/**
 * Signals in message TDT009_B003.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_tdt009_b003_t {
    /**
     * Range: 0..5000 (0..500 A)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t ac_curr_mea_rms;

    /**
     * Range: 0..6000 (-300..300 A)
     * Scale: 0.1
     * Offset: -300
     */
    uint16_t dc_curr_estd;

    /**
     * Range: 0..1000 (0..100 V)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t dc_bus_volt;

    /**
     * Range: 0..240000 (-12000..12000 rpm)
     * Scale: 0.1
     * Offset: -12000
     */
    uint32_t mtr_spd;

    /**
     * Range: 0..500 (0..5 V)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t throt_volt;
};

/**
 * Signals in message TDT008_B002.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_tdt008_b002_t {
    /**
     * Range: 0..4000 (-100..300 °C)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t ctrlr_temp1;

    /**
     * Range: 0..4000 (-100..300 °C)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t ctrlr_temp2;

    /**
     * Range: 0..4000 (-100..300 °C)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t ctrlr_temp;

    /**
     * Range: 0..4000 (-100..300 °C)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t mtr_temp;
};

/**
 * Signals in message TDT007_B001_Status.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_tdt007_b001_status_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t throt_mode;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eco_boost;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t limp_home_mode;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t forward;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t reverse;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t neutral;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t hillhold_mode;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t regen_mode;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dcu_control_mode_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t asc_mode;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t snsr_health_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t snsr_health_status_dc_bus;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t snsr_health_status12_v;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t snsr_health_status5_v;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t snsr_health_status_ph_b_curr;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t snsr_health_status_ph_c_curr;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t snsr_health_status_throt1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t snsr_health_status_throt2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t snsr_health_status_qep;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t snsr_health_status_mtr_temp;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t snsr_health_status_ctlr_temp1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t snsr_health_status_ctlr_temp2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pc_mode_enable;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t start_stop;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t idle_shutdown;
};

/**
 * Signals in message TDTFS001_Type.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_tdtfs001_type_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t can_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ctrlr_temp_cutback_lmt_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ctrlr_temp_cutoff_lmt_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ctrlr_temp_snsr_oc_flt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ctrlr_temp_snsr_sc_flt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dc_bus_ov_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dc_bus_snsr_oc_flt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dc_bus_snsr_sc_flt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dc_bus_uv_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mtr_temp_cutback_lmt_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mtr_temp_cutoff_lmt_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mtr_temp_snsr_oc_flt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mtr_temp_snsr_sc_flt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ph_b_curr_snsr_oc_flt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ph_b_curr_snsr_over_curr_flt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ph_b_curr_snsr_sc_curr_flt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ph_b_curr_snsr_sc_flt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ph_c_curr_snsr_oc_flt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ph_c_curr_snsr_over_curr_flt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ph_c_curr_snsr_sc_curr_flt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ph_c_curr_snsr_sc_flt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t qep_flt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t soc_low_lmt_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t throt_low_lmt_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t throt_redun_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t throt_stuck_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t throt_up_lmt_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t unexpected_park_sense_high_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t unintended_acceleration_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t unintended_deceleration_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dc_bus_lv_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t throt_snsr_oc_flt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t throt_snsr_sc_flt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fnr_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fnr_warn;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t supply12_snsr_oc_flt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t supply5_snsr_oc_flt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t supply12_uv_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t supply5_uv_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t hw_over_curr_flt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t type_0_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t type_1_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t type_2_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t type_3_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t type_4_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t qep_flt_2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ph_a_curr_snsr_over_curr_flt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ph_a_curr_snsr_sc_curr_flt;
};

/**
 * Signals in message DT011_FOC008_PiTuning.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_dt011_foc008_pi_tuning_t {
    /**
     * Range: 0..400 (-200..200 V)
     * Scale: 1
     * Offset: -200
     */
    uint16_t daxis_ffwd;

    /**
     * Range: 0..400 (-200..200 V)
     * Scale: 1
     * Offset: -200
     */
    uint16_t daxis_pi_out;

    /**
     * Range: 0..400 (-200..200 V)
     * Scale: 1
     * Offset: -200
     */
    uint16_t qaxis_ffwd;

    /**
     * Range: 0..400 (-200..200 V)
     * Scale: 1
     * Offset: -200
     */
    uint16_t qaxis_pi_output;

    /**
     * Range: 0..400 (-200..200 Nm)
     * Scale: 1
     * Offset: -200
     */
    uint16_t speed_pi_output;
};

/**
 * Signals in message DTCP014_Hillhold_PI.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_dtcp014_hillhold_pi_t {
    /**
     * Range: 0..1000000000 (0..1000 -)
     * Scale: 1e-06
     * Offset: 0
     */
    uint32_t ki_hillhold;

    /**
     * Range: 0..1000000000 (0..1000 -)
     * Scale: 1e-06
     * Offset: 0
     */
    uint32_t kp_hillhold;
};

/**
 * Signals in message DTCP013_Regen_PI.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_dtcp013_regen_pi_t {
    /**
     * Range: 0..1000000000 (0..1000 -)
     * Scale: 1e-06
     * Offset: 0
     */
    uint32_t ki_regen;

    /**
     * Range: 0..1000000000 (0..1000 -)
     * Scale: 1e-06
     * Offset: 0
     */
    uint32_t kp_regen;
};

/**
 * Signals in message DTCP012_FW_PI.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_dtcp012_fw_pi_t {
    /**
     * Range: 0..1000000000 (0..1000 -)
     * Scale: 1e-06
     * Offset: 0
     */
    uint32_t ki_fw;

    /**
     * Range: 0..1000000000 (0..1000 -)
     * Scale: 1e-06
     * Offset: 0
     */
    uint32_t kp_fw;
};

/**
 * Signals in message DTCP011_DCClamp_PI.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_dtcp011_dc_clamp_pi_t {
    /**
     * Range: 0..1000000000 (0..1000 -)
     * Scale: 1e-06
     * Offset: 0
     */
    uint32_t ki_dc_clamping;

    /**
     * Range: 0..1000000000 (0..1000 -)
     * Scale: 1e-06
     * Offset: 0
     */
    uint32_t kp_dc_clamping;
};

/**
 * Signals in message DTCP010_Speed_PI.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_dtcp010_speed_pi_t {
    /**
     * Range: 0..65535 (0..6.5535 -)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t ki_low_spd;

    /**
     * Range: 0..65535 (0..6.5535 -)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t ki_high_spd;

    /**
     * Range: 0..65535 (0..6.5535 -)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t kp_low_spd;

    /**
     * Range: 0..65535 (0..6.5535 -)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t kp_high_spd;
};

/**
 * Signals in message DTCP009_Iq_PI.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_dtcp009_iq_pi_t {
    /**
     * Range: 0..1000000000 (0..1000 -)
     * Scale: 1e-06
     * Offset: 0
     */
    uint32_t ki_iq;

    /**
     * Range: 0..1000000000 (0..1000 -)
     * Scale: 1e-06
     * Offset: 0
     */
    uint32_t kp_iq;
};

/**
 * Signals in message DTCP008_Id_PI.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_dtcp008_id_pi_t {
    /**
     * Range: 0..1000000000 (0..1000 -)
     * Scale: 1e-06
     * Offset: 0
     */
    uint32_t ki_id;

    /**
     * Range: 0..1000000000 (0..1000 -)
     * Scale: 1e-06
     * Offset: 0
     */
    uint32_t kp_id;
};

/**
 * Signals in message RTW014_Hillhold_PI.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_rtw014_hillhold_pi_t {
    /**
     * Range: 0..1000000000 (0..1000 -)
     * Scale: 1e-06
     * Offset: 0
     */
    uint32_t ki_hillhold;

    /**
     * Range: 0..1000000000 (0..1000 -)
     * Scale: 1e-06
     * Offset: 0
     */
    uint32_t kp_hillhold;
};

/**
 * Signals in message RTW013_Regen_PI.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_rtw013_regen_pi_t {
    /**
     * Range: 0..1000000000 (0..1000 -)
     * Scale: 1e-06
     * Offset: 0
     */
    uint32_t ki_regen;

    /**
     * Range: 0..1000000000 (0..1000 -)
     * Scale: 1e-06
     * Offset: 0
     */
    uint32_t kp_regen;
};

/**
 * Signals in message RTW012_FW_PI.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_rtw012_fw_pi_t {
    /**
     * Range: 0..1000000000 (0..1000 -)
     * Scale: 1e-06
     * Offset: 0
     */
    uint32_t ki_fw;

    /**
     * Range: 0..1000000000 (0..1000 -)
     * Scale: 1e-06
     * Offset: 0
     */
    uint32_t kp_fw;
};

/**
 * Signals in message RTW011_DCClamp_PI.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_rtw011_dc_clamp_pi_t {
    /**
     * Range: 0..1000000000 (0..1000 -)
     * Scale: 1e-06
     * Offset: 0
     */
    uint32_t ki_dc_clamping;

    /**
     * Range: 0..1000000000 (0..1000 -)
     * Scale: 1e-06
     * Offset: 0
     */
    uint32_t kp_dc_clamping;
};

/**
 * Signals in message RTW010_Speed_PI.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_rtw010_speed_pi_t {
    /**
     * Range: 0..65535 (0..6.5535 -)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t ki_low_spd;

    /**
     * Range: 0..65535 (0..6.5535 -)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t ki_high_spd;

    /**
     * Range: 0..65535 (0..6.5535 -)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t kp_low_spd;

    /**
     * Range: 0..65535 (0..6.5535 -)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t kp_high_spd;
};

/**
 * Signals in message RTW009_Iq_PI.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_rtw009_iq_pi_t {
    /**
     * Range: 0..1000000000 (0..1000 -)
     * Scale: 1e-06
     * Offset: 0
     */
    uint32_t ki_iq;

    /**
     * Range: 0..1000000000 (0..1000 -)
     * Scale: 1e-06
     * Offset: 0
     */
    uint32_t kp_iq;
};

/**
 * Signals in message RTW008_Id_PI.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_rtw008_id_pi_t {
    /**
     * Range: 0..1000000000 (0..1000 -)
     * Scale: 1e-06
     * Offset: 0
     */
    uint32_t ki_id;

    /**
     * Range: 0..1000000000 (0..1000 -)
     * Scale: 1e-06
     * Offset: 0
     */
    uint32_t kp_id;
};

/**
 * Signals in message TRTCC003.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_trtcc003_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t flash_cmd;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t start_stop;

    /**
     * Range: 0..8191 (0..8191 No.)
     * Scale: 1
     * Offset: 0
     */
    uint16_t flash_sample_number;
};

/**
 * Signals in message TDTACK002.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_tdtack002_t {
    /**
     * Range: 0..4 (0..4 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t flash_status;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t flash_err_address;
};

/**
 * Signals in message TRTW002.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_trtw002_t {
    /**
     * Range: 0..2400000 (-12000..12000 rpm)
     * Scale: 0.01
     * Offset: -12000
     */
    uint32_t spd_test_cmd_max;

    /**
     * Range: 0..100000 (-500..500 Nm)
     * Scale: 0.01
     * Offset: -500
     */
    uint32_t trq_test_cmd_max;

    /**
     * Range: 0..1023 (0..1023 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t drive_cycle_repetition_number;
};

/**
 * Signals in message TRTW001.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_trtw001_t {
    /**
     * Range: 0..1000000 (0..1 -)
     * Scale: 1e-06
     * Offset: 0
     */
    uint32_t spd_test_cmd_flash_factor;

    /**
     * Range: 0..1000000 (0..1 -)
     * Scale: 1e-06
     * Offset: 0
     */
    uint32_t trq_test_cmd_flash_factor;

    /**
     * Range: 0..16777215 (0..16777215 s)
     * Scale: 1
     * Offset: 0
     */
    uint32_t relative_time;
};

/**
 * Signals in message DTCP005.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_dtcp005_t {
    /**
     * Range: 0..8000 (0..8000 rpm/s)
     * Scale: 1
     * Offset: 0
     */
    uint16_t spd_slewrate_positive;

    /**
     * Range: 0..63 (0..63 V/s)
     * Scale: 1
     * Offset: 0
     */
    uint8_t throt_volt_slewrate_positive;

    /**
     * Range: 0..8000 (0..8000 rpm/s)
     * Scale: 1
     * Offset: 0
     */
    uint16_t spd_slewrate_negative;

    /**
     * Range: 0..63 (0..63 V/s)
     * Scale: 1
     * Offset: 0
     */
    uint8_t throt_volt_slewrate_negative;

    /**
     * Range: 0..72000 (-360..360 deg)
     * Scale: 0.01
     * Offset: -360
     */
    uint32_t autotuning_offset_angle;
};

/**
 * Signals in message DTACK001.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_dtack001_t {
    /**
     * Range: 0..72000 (-360..360 deg)
     * Scale: 0.01
     * Offset: -360
     */
    uint32_t autotuning_offset_angle;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t config_update_status;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t autotuning_config_update_status;
};

/**
 * Signals in message RTCC004.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_rtcc004_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pc_mode_enable;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t config_update_enable;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t control_update_enable;

    /**
     * Range: 0..7 (-1..6 -)
     * Scale: 1
     * Offset: -1
     */
    uint8_t user_access_level;
};

/**
 * Signals in message DTCP007.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_dtcp007_t {
    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t serial_number;

    /**
     * Range: 0..65535 (0..65.535 -)
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t sw_version_major;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sw_version_minor;
};

/**
 * Signals in message RTW007.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_rtw007_t {
    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t serial_number;
};

/**
 * Signals in message RTCC003.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_rtcc003_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t update_config_para;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fetch_config_para;

    /**
     * Range: 0..16383 (0..1638.3 -)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t cc_para1;

    /**
     * Range: 0..65535 (0..6553.5 -)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t cc_para2;

    /**
     * Range: 0..65535 (0..6553.5 -)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t cc_para3;

    /**
     * Range: 0..65535 (0..6553.5 -)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t cc_para4;
};

/**
 * Signals in message RTDT001.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_rtdt001_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t gui_connection;
};

/**
 * Signals in message DT009_B003.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_dt009_b003_t {
    /**
     * Range: 0..5000 (0..500 A)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t ac_curr_mea_rms;

    /**
     * Range: 0..6000 (-300..300 A)
     * Scale: 0.1
     * Offset: -300
     */
    uint16_t dc_curr_estd;

    /**
     * Range: 0..1000 (0..100 V)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t dc_bus_volt;

    /**
     * Range: 0..240000 (-12000..12000 rpm)
     * Scale: 0.1
     * Offset: -12000
     */
    uint32_t mtr_spd;

    /**
     * Range: 0..500 (0..5 V)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t throt_volt;
};

/**
 * Signals in message RTW005.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_rtw005_t {
    /**
     * Range: 0..8000 (0..8000 rpm/s)
     * Scale: 1
     * Offset: 0
     */
    uint16_t spd_slewrate_positive;

    /**
     * Range: 0..63 (0..63 V/s)
     * Scale: 1
     * Offset: 0
     */
    uint8_t throt_volt_slewrate_positive;

    /**
     * Range: 0..8000 (0..8000 rpm/s)
     * Scale: 1
     * Offset: 0
     */
    uint16_t spd_slewrate_negative;

    /**
     * Range: 0..63 (0..63 V/s)
     * Scale: 1
     * Offset: 0
     */
    uint8_t throt_volt_slewrate_negative;
};

/**
 * Signals in message RTCC002.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_rtcc002_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fwd_rev;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eco_boost;

    /**
     * Range: 0..1000 (0..100 %)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t spd_percentage;

    /**
     * Range: 0..120000 (0..12000 rpm)
     * Scale: 0.1
     * Offset: 0
     */
    uint32_t run_spd;

    /**
     * Range: 0..1000 (0..100 %)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t throt_percentage;

    /**
     * Range: 0..1000 (0..100 Nm)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t run_trq;
};

/**
 * Signals in message DTCP004.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_dtcp004_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t throt_type;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fnr_type;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t direc_of_fwd_rotation;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t start_avail;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t park_avail;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t charger_avail;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cruise_avail;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t kill_avail;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t eco_boost_avail;
};

/**
 * Signals in message RTW004.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_rtw004_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t throt_type;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fnr_type;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t direc_of_fwd_rotation;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t start_avail;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t park_avail;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t charger_avail;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cruise_avail;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t kill_avail;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t eco_boost_avail;
};

/**
 * Signals in message DTCP003.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_dtcp003_t {
    /**
     * Range: 0..15000 (0..15000 W)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pwr_peak_eco;

    /**
     * Range: 0..3000 (0..300 °C)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t mtr_temp_cutback_lmt;

    /**
     * Range: 0..3000 (0..300 °C)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t mtr_temp_cutoff_lmt;

    /**
     * Range: 0..3000 (0..300 °C)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t ctrlr_temp_cutback_lmt;

    /**
     * Range: 0..3000 (0..300 °C)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t ctrlr_temp_cutoff_lmt;

    /**
     * Range: 0..2 (0..2 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dcu_control_mode;
};

/**
 * Signals in message RTW003.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_rtw003_t {
    /**
     * Range: 0..15000 (0..15000 W)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pwr_peak_eco;

    /**
     * Range: 0..3000 (0..300 °C)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t mtr_temp_cutback_lmt;

    /**
     * Range: 0..3000 (0..300 °C)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t mtr_temp_cutoff_lmt;

    /**
     * Range: 0..3000 (0..300 °C)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t ctrlr_temp_cutback_lmt;

    /**
     * Range: 0..3000 (0..300 °C)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t ctrlr_temp_cutoff_lmt;

    /**
     * Range: 0..2 (0..2 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dcu_control_mode;
};

/**
 * Signals in message RTCC001.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_rtcc001_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t snsr_health_trigg;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t start_stop;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t park;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t charger;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cruise;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t kill;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sw_rst;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t autotuning_cmd;
};

/**
 * Signals in message DTFS001_Type.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_dtfs001_type_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t can_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ctrlr_temp_cutback_lmt_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ctrlr_temp_cutoff_lmt_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ctrlr_temp_snsr_oc_flt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ctrlr_temp_snsr_sc_flt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dc_bus_ov_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dc_bus_snsr_oc_flt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dc_bus_snsr_sc_flt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dc_bus_uv_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mtr_temp_cutback_lmt_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mtr_temp_cutoff_lmt_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mtr_temp_snsr_oc_flt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mtr_temp_snsr_sc_flt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ph_b_curr_snsr_oc_flt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ph_b_curr_snsr_over_curr_flt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ph_b_curr_snsr_sc_curr_flt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ph_b_curr_snsr_sc_flt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ph_c_curr_snsr_oc_flt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ph_c_curr_snsr_over_curr_flt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ph_c_curr_snsr_sc_curr_flt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ph_c_curr_snsr_sc_flt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t qep_flt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t soc_low_lmt_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t throt_low_lmt_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t throt_redun_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t throt_stuck_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t throt_up_lmt_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t unexpected_park_sense_high_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t unintended_acceleration_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t unintended_deceleration_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dc_bus_lv_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t throt_snsr_oc_flt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t throt_snsr_sc_flt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fnr_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fnr_warn;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t supply12_snsr_oc_flt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t supply5_snsr_oc_flt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t supply12_uv_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t supply5_uv_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t hw_over_curr_flt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t type_0_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t type_1_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t type_2_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t type_3_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t type_4_err;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t qep_flt_2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ph_a_curr_snsr_over_curr_flt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ph_a_curr_snsr_sc_curr_flt;
};

/**
 * Signals in message DTCP002.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_dtcp002_t {
    /**
     * Range: 0..120000 (0..12000 rpm)
     * Scale: 0.1
     * Offset: 0
     */
    uint32_t spd_max_fwd;

    /**
     * Range: 0..5000 (0..500 Nm)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t trq_max;

    /**
     * Range: 0..120000 (0..12000 rpm)
     * Scale: 0.1
     * Offset: 0
     */
    uint32_t spd_max_rev;

    /**
     * Range: 0..50 (0..5 V)
     * Scale: 0.1
     * Offset: 0
     */
    uint8_t throt_low_lmt;

    /**
     * Range: 0..50 (0..5 V)
     * Scale: 0.1
     * Offset: 0
     */
    uint8_t throt_up_lmt;
};

/**
 * Signals in message DTCP001.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_dtcp001_t {
    /**
     * Range: 0..4000 (0..400 A)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t ac_curr_max_rms;

    /**
     * Range: 0..3000 (0..300 A)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t dc_curr_max;

    /**
     * Range: 0..1000 (0..100 V)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t ov_lmt;

    /**
     * Range: 0..1000 (0..100 V)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t uv_lmt;

    /**
     * Range: 0..2000 (0..200 A)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t regen_curr_max_lmt;
};

/**
 * Signals in message RTW002.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_rtw002_t {
    /**
     * Range: 0..120000 (0..12000 rpm)
     * Scale: 0.1
     * Offset: 0
     */
    uint32_t spd_max_fwd;

    /**
     * Range: 0..5000 (0..500 Nm)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t trq_max;

    /**
     * Range: 0..120000 (0..12000 rpm)
     * Scale: 0.1
     * Offset: 0
     */
    uint32_t spd_max_rev;

    /**
     * Range: 0..50 (0..5 V)
     * Scale: 0.1
     * Offset: 0
     */
    uint8_t throt_low_lmt;

    /**
     * Range: 0..50 (0..5 V)
     * Scale: 0.1
     * Offset: 0
     */
    uint8_t throt_up_lmt;
};

/**
 * Signals in message RTW001.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_rtw001_t {
    /**
     * Range: 0..4000 (0..400 A)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t ac_curr_max_rms;

    /**
     * Range: 0..3000 (0..300 A)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t dc_curr_max;

    /**
     * Range: 0..1000 (0..100 V)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t ov_lmt;

    /**
     * Range: 0..1000 (0..100 V)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t uv_lmt;

    /**
     * Range: 0..2000 (0..200 A)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t regen_curr_max_lmt;
};

/**
 * Signals in message DT008_B002.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_dt008_b002_t {
    /**
     * Range: 0..4000 (-100..300 °C)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t ctrlr_temp1;

    /**
     * Range: 0..4000 (-100..300 °C)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t ctrlr_temp2;

    /**
     * Range: 0..4000 (-100..300 °C)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t ctrlr_temp;

    /**
     * Range: 0..4000 (-100..300 °C)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t mtr_temp;
};

/**
 * Signals in message DT007_B001_Status.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_dt007_b001_status_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t throt_mode;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eco_boost;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t limp_home_mode;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t forward;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t reverse;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t neutral;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t hillhold_mode;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t regen_mode;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dcu_control_mode_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t asc_mode;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t snsr_health_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t snsr_health_status_dc_bus;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t snsr_health_status12_v;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t snsr_health_status5_v;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t snsr_health_status_ph_b_curr;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t snsr_health_status_ph_c_curr;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t snsr_health_status_throt1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t snsr_health_status_throt2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t snsr_health_status_qep;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t snsr_health_status_mtr_temp;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t snsr_health_status_ctlr_temp1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t snsr_health_status_ctlr_temp2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pc_mode_enable;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t start_stop;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t idle_shutdown;
};

/**
 * Signals in message DT006_FOC006.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_dt006_foc006_t {
    /**
     * Range: 0..5000 (0..500 Nm)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t throt_trq;

    /**
     * Range: 0..2000 (-100..100 V)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t fw_err;

    /**
     * Range: 0..240000 (-12000..12000 rpm)
     * Scale: 0.1
     * Offset: -12000
     */
    uint32_t spd_err;

    /**
     * Range: 0..7200 (-360..360 deg)
     * Scale: 0.1
     * Offset: -360
     */
    uint16_t pos_err;
};

/**
 * Signals in message DT005_FOC005.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_dt005_foc005_t {
    /**
     * Range: 0..12000 (-600..600 A)
     * Scale: 0.1
     * Offset: -600
     */
    uint16_t daxis_curr_err;

    /**
     * Range: 0..12000 (-600..600 A)
     * Scale: 0.1
     * Offset: -600
     */
    uint16_t qaxis_curr_err;

    /**
     * Range: 0..6000 (-300..300 A)
     * Scale: 0.1
     * Offset: -300
     */
    uint16_t dc_curr_clamp_err;

    /**
     * Range: 0..100 (0..1 -)
     * Scale: 0.01
     * Offset: 0
     */
    uint8_t mi;

    /**
     * Range: 0..16000 (-8000..8000 rpm)
     * Scale: 1
     * Offset: -8000
     */
    uint16_t dc_clamp_spd;
};

/**
 * Signals in message DT004_FOC004.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_dt004_foc004_t {
    /**
     * Range: 0..2000 (-1000..1000 A)
     * Scale: 1
     * Offset: -1000
     */
    uint16_t ph_a_curr;

    /**
     * Range: 0..2000 (-1000..1000 A)
     * Scale: 1
     * Offset: -1000
     */
    uint16_t ph_b_curr;

    /**
     * Range: 0..2000 (-1000..1000 A)
     * Scale: 1
     * Offset: -1000
     */
    uint16_t ph_c_curr;
};

/**
 * Signals in message DT003_FOC003_DCCurrentModule.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_dt003_foc003_dc_current_module_t {
    /**
     * Range: 0..12000 (-600..600 A)
     * Scale: 0.1
     * Offset: -600
     */
    uint16_t daxis_curr_mea;

    /**
     * Range: 0..12000 (-600..600 A)
     * Scale: 0.1
     * Offset: -600
     */
    uint16_t qaxis_curr_mea;

    /**
     * Range: 0..2000 (-100..100 V)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t daxis_volt;

    /**
     * Range: 0..2000 (-100..100 V)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t qaxis_volt;

    /**
     * Range: 0..6000 (-300..300 A)
     * Scale: 0.1
     * Offset: -300
     */
    uint16_t daxis_curr_fw_ref;
};

/**
 * Signals in message DT002_FOC002_DQCurrentMeaRef.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_dt002_foc002_dq_current_mea_ref_t {
    /**
     * Range: 0..12000 (-600..600 A)
     * Scale: 0.1
     * Offset: -600
     */
    uint16_t daxis_curr_ref;

    /**
     * Range: 0..12000 (-600..600 A)
     * Scale: 0.1
     * Offset: -600
     */
    uint16_t daxis_curr_mea;

    /**
     * Range: 0..12000 (-600..600 A)
     * Scale: 0.1
     * Offset: -600
     */
    uint16_t qaxis_curr_ref;

    /**
     * Range: 0..12000 (-600..600 A)
     * Scale: 0.1
     * Offset: -600
     */
    uint16_t qaxis_curr_mea;
};

/**
 * Signals in message DT001_FOC001_SpeedTorqueRef.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_v08_1_dt001_foc001_speed_torque_ref_t {
    /**
     * Range: 0..240000 (-12000..12000 rpm)
     * Scale: 0.1
     * Offset: -12000
     */
    uint32_t spd_ref;

    /**
     * Range: 0..2000 (-100..100 Nm)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t trq_ref;

    /**
     * Range: 0..16000 (-8000..8000 rpm)
     * Scale: 1
     * Offset: -8000
     */
    uint16_t dc_clamp_spd;
};

/**
 * Pack message TDT009_B003.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_tdt009_b003_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_tdt009_b003_t *src_p,
    size_t size);

/**
 * Unpack message TDT009_B003.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_tdt009_b003_unpack(
    struct dbc_v08_1_tdt009_b003_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from TDT009_B003.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_tdt009_b003_init(struct dbc_v08_1_tdt009_b003_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_tdt009_b003_ac_curr_mea_rms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdt009_b003_ac_curr_mea_rms_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdt009_b003_ac_curr_mea_rms_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_tdt009_b003_dc_curr_estd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdt009_b003_dc_curr_estd_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdt009_b003_dc_curr_estd_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_tdt009_b003_dc_bus_volt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdt009_b003_dc_bus_volt_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdt009_b003_dc_bus_volt_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dbc_v08_1_tdt009_b003_mtr_spd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdt009_b003_mtr_spd_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdt009_b003_mtr_spd_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_tdt009_b003_throt_volt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdt009_b003_throt_volt_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdt009_b003_throt_volt_is_in_range(uint16_t value);

/**
 * Pack message TDT008_B002.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_tdt008_b002_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_tdt008_b002_t *src_p,
    size_t size);

/**
 * Unpack message TDT008_B002.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_tdt008_b002_unpack(
    struct dbc_v08_1_tdt008_b002_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from TDT008_B002.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_tdt008_b002_init(struct dbc_v08_1_tdt008_b002_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_tdt008_b002_ctrlr_temp1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdt008_b002_ctrlr_temp1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdt008_b002_ctrlr_temp1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_tdt008_b002_ctrlr_temp2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdt008_b002_ctrlr_temp2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdt008_b002_ctrlr_temp2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_tdt008_b002_ctrlr_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdt008_b002_ctrlr_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdt008_b002_ctrlr_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_tdt008_b002_mtr_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdt008_b002_mtr_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdt008_b002_mtr_temp_is_in_range(uint16_t value);

/**
 * Pack message TDT007_B001_Status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_tdt007_b001_status_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_tdt007_b001_status_t *src_p,
    size_t size);

/**
 * Unpack message TDT007_B001_Status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_tdt007_b001_status_unpack(
    struct dbc_v08_1_tdt007_b001_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from TDT007_B001_Status.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_tdt007_b001_status_init(struct dbc_v08_1_tdt007_b001_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdt007_b001_status_throt_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdt007_b001_status_throt_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdt007_b001_status_throt_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdt007_b001_status_eco_boost_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdt007_b001_status_eco_boost_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdt007_b001_status_eco_boost_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdt007_b001_status_limp_home_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdt007_b001_status_limp_home_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdt007_b001_status_limp_home_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdt007_b001_status_brake_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdt007_b001_status_brake_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdt007_b001_status_brake_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdt007_b001_status_forward_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdt007_b001_status_forward_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdt007_b001_status_forward_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdt007_b001_status_reverse_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdt007_b001_status_reverse_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdt007_b001_status_reverse_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdt007_b001_status_neutral_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdt007_b001_status_neutral_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdt007_b001_status_neutral_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdt007_b001_status_hillhold_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdt007_b001_status_hillhold_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdt007_b001_status_hillhold_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdt007_b001_status_regen_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdt007_b001_status_regen_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdt007_b001_status_regen_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdt007_b001_status_dcu_control_mode_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdt007_b001_status_dcu_control_mode_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdt007_b001_status_dcu_control_mode_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdt007_b001_status_asc_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdt007_b001_status_asc_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdt007_b001_status_asc_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdt007_b001_status_snsr_health_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdt007_b001_status_snsr_health_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdt007_b001_status_snsr_health_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdt007_b001_status_snsr_health_status_dc_bus_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdt007_b001_status_snsr_health_status_dc_bus_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdt007_b001_status_snsr_health_status_dc_bus_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdt007_b001_status_snsr_health_status12_v_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdt007_b001_status_snsr_health_status12_v_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdt007_b001_status_snsr_health_status12_v_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdt007_b001_status_snsr_health_status5_v_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdt007_b001_status_snsr_health_status5_v_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdt007_b001_status_snsr_health_status5_v_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdt007_b001_status_snsr_health_status_ph_b_curr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdt007_b001_status_snsr_health_status_ph_b_curr_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdt007_b001_status_snsr_health_status_ph_b_curr_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdt007_b001_status_snsr_health_status_ph_c_curr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdt007_b001_status_snsr_health_status_ph_c_curr_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdt007_b001_status_snsr_health_status_ph_c_curr_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdt007_b001_status_snsr_health_status_throt1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdt007_b001_status_snsr_health_status_throt1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdt007_b001_status_snsr_health_status_throt1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdt007_b001_status_snsr_health_status_throt2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdt007_b001_status_snsr_health_status_throt2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdt007_b001_status_snsr_health_status_throt2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdt007_b001_status_snsr_health_status_qep_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdt007_b001_status_snsr_health_status_qep_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdt007_b001_status_snsr_health_status_qep_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdt007_b001_status_snsr_health_status_mtr_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdt007_b001_status_snsr_health_status_mtr_temp_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdt007_b001_status_snsr_health_status_mtr_temp_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdt007_b001_status_snsr_health_status_ctlr_temp1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdt007_b001_status_snsr_health_status_ctlr_temp1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdt007_b001_status_snsr_health_status_ctlr_temp1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdt007_b001_status_snsr_health_status_ctlr_temp2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdt007_b001_status_snsr_health_status_ctlr_temp2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdt007_b001_status_snsr_health_status_ctlr_temp2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdt007_b001_status_pc_mode_enable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdt007_b001_status_pc_mode_enable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdt007_b001_status_pc_mode_enable_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdt007_b001_status_start_stop_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdt007_b001_status_start_stop_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdt007_b001_status_start_stop_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdt007_b001_status_idle_shutdown_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdt007_b001_status_idle_shutdown_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdt007_b001_status_idle_shutdown_is_in_range(uint8_t value);

/**
 * Pack message TDTFS001_Type.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_tdtfs001_type_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_tdtfs001_type_t *src_p,
    size_t size);

/**
 * Unpack message TDTFS001_Type.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_tdtfs001_type_unpack(
    struct dbc_v08_1_tdtfs001_type_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from TDTFS001_Type.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_tdtfs001_type_init(struct dbc_v08_1_tdtfs001_type_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_can_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_can_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_can_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_ctrlr_temp_cutback_lmt_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_ctrlr_temp_cutback_lmt_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_ctrlr_temp_cutback_lmt_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_ctrlr_temp_cutoff_lmt_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_ctrlr_temp_cutoff_lmt_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_ctrlr_temp_cutoff_lmt_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_ctrlr_temp_snsr_oc_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_ctrlr_temp_snsr_oc_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_ctrlr_temp_snsr_oc_flt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_ctrlr_temp_snsr_sc_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_ctrlr_temp_snsr_sc_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_ctrlr_temp_snsr_sc_flt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_dc_bus_ov_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_dc_bus_ov_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_dc_bus_ov_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_dc_bus_snsr_oc_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_dc_bus_snsr_oc_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_dc_bus_snsr_oc_flt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_dc_bus_snsr_sc_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_dc_bus_snsr_sc_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_dc_bus_snsr_sc_flt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_dc_bus_uv_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_dc_bus_uv_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_dc_bus_uv_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_mtr_temp_cutback_lmt_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_mtr_temp_cutback_lmt_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_mtr_temp_cutback_lmt_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_mtr_temp_cutoff_lmt_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_mtr_temp_cutoff_lmt_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_mtr_temp_cutoff_lmt_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_mtr_temp_snsr_oc_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_mtr_temp_snsr_oc_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_mtr_temp_snsr_oc_flt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_mtr_temp_snsr_sc_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_mtr_temp_snsr_sc_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_mtr_temp_snsr_sc_flt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_ph_b_curr_snsr_oc_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_ph_b_curr_snsr_oc_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_ph_b_curr_snsr_oc_flt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_ph_b_curr_snsr_over_curr_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_ph_b_curr_snsr_over_curr_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_ph_b_curr_snsr_over_curr_flt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_ph_b_curr_snsr_sc_curr_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_ph_b_curr_snsr_sc_curr_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_ph_b_curr_snsr_sc_curr_flt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_ph_b_curr_snsr_sc_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_ph_b_curr_snsr_sc_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_ph_b_curr_snsr_sc_flt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_ph_c_curr_snsr_oc_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_ph_c_curr_snsr_oc_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_ph_c_curr_snsr_oc_flt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_ph_c_curr_snsr_over_curr_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_ph_c_curr_snsr_over_curr_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_ph_c_curr_snsr_over_curr_flt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_ph_c_curr_snsr_sc_curr_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_ph_c_curr_snsr_sc_curr_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_ph_c_curr_snsr_sc_curr_flt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_ph_c_curr_snsr_sc_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_ph_c_curr_snsr_sc_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_ph_c_curr_snsr_sc_flt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_qep_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_qep_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_qep_flt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_soc_low_lmt_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_soc_low_lmt_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_soc_low_lmt_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_throt_low_lmt_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_throt_low_lmt_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_throt_low_lmt_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_throt_redun_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_throt_redun_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_throt_redun_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_throt_stuck_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_throt_stuck_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_throt_stuck_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_throt_up_lmt_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_throt_up_lmt_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_throt_up_lmt_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_unexpected_park_sense_high_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_unexpected_park_sense_high_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_unexpected_park_sense_high_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_unintended_acceleration_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_unintended_acceleration_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_unintended_acceleration_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_unintended_deceleration_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_unintended_deceleration_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_unintended_deceleration_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_dc_bus_lv_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_dc_bus_lv_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_dc_bus_lv_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_throt_snsr_oc_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_throt_snsr_oc_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_throt_snsr_oc_flt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_throt_snsr_sc_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_throt_snsr_sc_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_throt_snsr_sc_flt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_fnr_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_fnr_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_fnr_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_fnr_warn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_fnr_warn_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_fnr_warn_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_supply12_snsr_oc_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_supply12_snsr_oc_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_supply12_snsr_oc_flt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_supply5_snsr_oc_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_supply5_snsr_oc_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_supply5_snsr_oc_flt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_supply12_uv_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_supply12_uv_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_supply12_uv_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_supply5_uv_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_supply5_uv_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_supply5_uv_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_hw_over_curr_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_hw_over_curr_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_hw_over_curr_flt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_type_0_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_type_0_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_type_0_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_type_1_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_type_1_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_type_1_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_type_2_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_type_2_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_type_2_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_type_3_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_type_3_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_type_3_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_type_4_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_type_4_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_type_4_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_qep_flt_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_qep_flt_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_qep_flt_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_ph_a_curr_snsr_over_curr_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_ph_a_curr_snsr_over_curr_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_ph_a_curr_snsr_over_curr_flt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtfs001_type_ph_a_curr_snsr_sc_curr_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtfs001_type_ph_a_curr_snsr_sc_curr_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtfs001_type_ph_a_curr_snsr_sc_curr_flt_is_in_range(uint8_t value);

/**
 * Pack message DT011_FOC008_PiTuning.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_dt011_foc008_pi_tuning_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_dt011_foc008_pi_tuning_t *src_p,
    size_t size);

/**
 * Unpack message DT011_FOC008_PiTuning.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_dt011_foc008_pi_tuning_unpack(
    struct dbc_v08_1_dt011_foc008_pi_tuning_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DT011_FOC008_PiTuning.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_dt011_foc008_pi_tuning_init(struct dbc_v08_1_dt011_foc008_pi_tuning_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dt011_foc008_pi_tuning_daxis_ffwd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt011_foc008_pi_tuning_daxis_ffwd_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt011_foc008_pi_tuning_daxis_ffwd_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dt011_foc008_pi_tuning_daxis_pi_out_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt011_foc008_pi_tuning_daxis_pi_out_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt011_foc008_pi_tuning_daxis_pi_out_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dt011_foc008_pi_tuning_qaxis_ffwd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt011_foc008_pi_tuning_qaxis_ffwd_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt011_foc008_pi_tuning_qaxis_ffwd_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dt011_foc008_pi_tuning_qaxis_pi_output_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt011_foc008_pi_tuning_qaxis_pi_output_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt011_foc008_pi_tuning_qaxis_pi_output_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dt011_foc008_pi_tuning_speed_pi_output_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt011_foc008_pi_tuning_speed_pi_output_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt011_foc008_pi_tuning_speed_pi_output_is_in_range(uint16_t value);

/**
 * Pack message DTCP014_Hillhold_PI.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_dtcp014_hillhold_pi_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_dtcp014_hillhold_pi_t *src_p,
    size_t size);

/**
 * Unpack message DTCP014_Hillhold_PI.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_dtcp014_hillhold_pi_unpack(
    struct dbc_v08_1_dtcp014_hillhold_pi_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DTCP014_Hillhold_PI.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_dtcp014_hillhold_pi_init(struct dbc_v08_1_dtcp014_hillhold_pi_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dbc_v08_1_dtcp014_hillhold_pi_ki_hillhold_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp014_hillhold_pi_ki_hillhold_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp014_hillhold_pi_ki_hillhold_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dbc_v08_1_dtcp014_hillhold_pi_kp_hillhold_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp014_hillhold_pi_kp_hillhold_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp014_hillhold_pi_kp_hillhold_is_in_range(uint32_t value);

/**
 * Pack message DTCP013_Regen_PI.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_dtcp013_regen_pi_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_dtcp013_regen_pi_t *src_p,
    size_t size);

/**
 * Unpack message DTCP013_Regen_PI.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_dtcp013_regen_pi_unpack(
    struct dbc_v08_1_dtcp013_regen_pi_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DTCP013_Regen_PI.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_dtcp013_regen_pi_init(struct dbc_v08_1_dtcp013_regen_pi_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dbc_v08_1_dtcp013_regen_pi_ki_regen_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp013_regen_pi_ki_regen_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp013_regen_pi_ki_regen_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dbc_v08_1_dtcp013_regen_pi_kp_regen_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp013_regen_pi_kp_regen_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp013_regen_pi_kp_regen_is_in_range(uint32_t value);

/**
 * Pack message DTCP012_FW_PI.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_dtcp012_fw_pi_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_dtcp012_fw_pi_t *src_p,
    size_t size);

/**
 * Unpack message DTCP012_FW_PI.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_dtcp012_fw_pi_unpack(
    struct dbc_v08_1_dtcp012_fw_pi_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DTCP012_FW_PI.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_dtcp012_fw_pi_init(struct dbc_v08_1_dtcp012_fw_pi_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dbc_v08_1_dtcp012_fw_pi_ki_fw_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp012_fw_pi_ki_fw_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp012_fw_pi_ki_fw_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dbc_v08_1_dtcp012_fw_pi_kp_fw_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp012_fw_pi_kp_fw_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp012_fw_pi_kp_fw_is_in_range(uint32_t value);

/**
 * Pack message DTCP011_DCClamp_PI.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_dtcp011_dc_clamp_pi_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_dtcp011_dc_clamp_pi_t *src_p,
    size_t size);

/**
 * Unpack message DTCP011_DCClamp_PI.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_dtcp011_dc_clamp_pi_unpack(
    struct dbc_v08_1_dtcp011_dc_clamp_pi_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DTCP011_DCClamp_PI.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_dtcp011_dc_clamp_pi_init(struct dbc_v08_1_dtcp011_dc_clamp_pi_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dbc_v08_1_dtcp011_dc_clamp_pi_ki_dc_clamping_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp011_dc_clamp_pi_ki_dc_clamping_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp011_dc_clamp_pi_ki_dc_clamping_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dbc_v08_1_dtcp011_dc_clamp_pi_kp_dc_clamping_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp011_dc_clamp_pi_kp_dc_clamping_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp011_dc_clamp_pi_kp_dc_clamping_is_in_range(uint32_t value);

/**
 * Pack message DTCP010_Speed_PI.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_dtcp010_speed_pi_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_dtcp010_speed_pi_t *src_p,
    size_t size);

/**
 * Unpack message DTCP010_Speed_PI.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_dtcp010_speed_pi_unpack(
    struct dbc_v08_1_dtcp010_speed_pi_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DTCP010_Speed_PI.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_dtcp010_speed_pi_init(struct dbc_v08_1_dtcp010_speed_pi_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dtcp010_speed_pi_ki_low_spd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp010_speed_pi_ki_low_spd_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp010_speed_pi_ki_low_spd_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dtcp010_speed_pi_ki_high_spd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp010_speed_pi_ki_high_spd_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp010_speed_pi_ki_high_spd_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dtcp010_speed_pi_kp_low_spd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp010_speed_pi_kp_low_spd_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp010_speed_pi_kp_low_spd_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dtcp010_speed_pi_kp_high_spd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp010_speed_pi_kp_high_spd_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp010_speed_pi_kp_high_spd_is_in_range(uint16_t value);

/**
 * Pack message DTCP009_Iq_PI.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_dtcp009_iq_pi_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_dtcp009_iq_pi_t *src_p,
    size_t size);

/**
 * Unpack message DTCP009_Iq_PI.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_dtcp009_iq_pi_unpack(
    struct dbc_v08_1_dtcp009_iq_pi_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DTCP009_Iq_PI.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_dtcp009_iq_pi_init(struct dbc_v08_1_dtcp009_iq_pi_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dbc_v08_1_dtcp009_iq_pi_ki_iq_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp009_iq_pi_ki_iq_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp009_iq_pi_ki_iq_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dbc_v08_1_dtcp009_iq_pi_kp_iq_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp009_iq_pi_kp_iq_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp009_iq_pi_kp_iq_is_in_range(uint32_t value);

/**
 * Pack message DTCP008_Id_PI.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_dtcp008_id_pi_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_dtcp008_id_pi_t *src_p,
    size_t size);

/**
 * Unpack message DTCP008_Id_PI.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_dtcp008_id_pi_unpack(
    struct dbc_v08_1_dtcp008_id_pi_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DTCP008_Id_PI.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_dtcp008_id_pi_init(struct dbc_v08_1_dtcp008_id_pi_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dbc_v08_1_dtcp008_id_pi_ki_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp008_id_pi_ki_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp008_id_pi_ki_id_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dbc_v08_1_dtcp008_id_pi_kp_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp008_id_pi_kp_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp008_id_pi_kp_id_is_in_range(uint32_t value);

/**
 * Pack message RTW014_Hillhold_PI.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_rtw014_hillhold_pi_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_rtw014_hillhold_pi_t *src_p,
    size_t size);

/**
 * Unpack message RTW014_Hillhold_PI.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_rtw014_hillhold_pi_unpack(
    struct dbc_v08_1_rtw014_hillhold_pi_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RTW014_Hillhold_PI.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_rtw014_hillhold_pi_init(struct dbc_v08_1_rtw014_hillhold_pi_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dbc_v08_1_rtw014_hillhold_pi_ki_hillhold_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw014_hillhold_pi_ki_hillhold_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw014_hillhold_pi_ki_hillhold_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dbc_v08_1_rtw014_hillhold_pi_kp_hillhold_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw014_hillhold_pi_kp_hillhold_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw014_hillhold_pi_kp_hillhold_is_in_range(uint32_t value);

/**
 * Pack message RTW013_Regen_PI.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_rtw013_regen_pi_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_rtw013_regen_pi_t *src_p,
    size_t size);

/**
 * Unpack message RTW013_Regen_PI.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_rtw013_regen_pi_unpack(
    struct dbc_v08_1_rtw013_regen_pi_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RTW013_Regen_PI.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_rtw013_regen_pi_init(struct dbc_v08_1_rtw013_regen_pi_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dbc_v08_1_rtw013_regen_pi_ki_regen_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw013_regen_pi_ki_regen_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw013_regen_pi_ki_regen_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dbc_v08_1_rtw013_regen_pi_kp_regen_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw013_regen_pi_kp_regen_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw013_regen_pi_kp_regen_is_in_range(uint32_t value);

/**
 * Pack message RTW012_FW_PI.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_rtw012_fw_pi_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_rtw012_fw_pi_t *src_p,
    size_t size);

/**
 * Unpack message RTW012_FW_PI.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_rtw012_fw_pi_unpack(
    struct dbc_v08_1_rtw012_fw_pi_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RTW012_FW_PI.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_rtw012_fw_pi_init(struct dbc_v08_1_rtw012_fw_pi_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dbc_v08_1_rtw012_fw_pi_ki_fw_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw012_fw_pi_ki_fw_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw012_fw_pi_ki_fw_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dbc_v08_1_rtw012_fw_pi_kp_fw_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw012_fw_pi_kp_fw_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw012_fw_pi_kp_fw_is_in_range(uint32_t value);

/**
 * Pack message RTW011_DCClamp_PI.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_rtw011_dc_clamp_pi_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_rtw011_dc_clamp_pi_t *src_p,
    size_t size);

/**
 * Unpack message RTW011_DCClamp_PI.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_rtw011_dc_clamp_pi_unpack(
    struct dbc_v08_1_rtw011_dc_clamp_pi_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RTW011_DCClamp_PI.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_rtw011_dc_clamp_pi_init(struct dbc_v08_1_rtw011_dc_clamp_pi_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dbc_v08_1_rtw011_dc_clamp_pi_ki_dc_clamping_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw011_dc_clamp_pi_ki_dc_clamping_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw011_dc_clamp_pi_ki_dc_clamping_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dbc_v08_1_rtw011_dc_clamp_pi_kp_dc_clamping_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw011_dc_clamp_pi_kp_dc_clamping_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw011_dc_clamp_pi_kp_dc_clamping_is_in_range(uint32_t value);

/**
 * Pack message RTW010_Speed_PI.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_rtw010_speed_pi_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_rtw010_speed_pi_t *src_p,
    size_t size);

/**
 * Unpack message RTW010_Speed_PI.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_rtw010_speed_pi_unpack(
    struct dbc_v08_1_rtw010_speed_pi_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RTW010_Speed_PI.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_rtw010_speed_pi_init(struct dbc_v08_1_rtw010_speed_pi_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_rtw010_speed_pi_ki_low_spd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw010_speed_pi_ki_low_spd_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw010_speed_pi_ki_low_spd_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_rtw010_speed_pi_ki_high_spd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw010_speed_pi_ki_high_spd_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw010_speed_pi_ki_high_spd_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_rtw010_speed_pi_kp_low_spd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw010_speed_pi_kp_low_spd_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw010_speed_pi_kp_low_spd_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_rtw010_speed_pi_kp_high_spd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw010_speed_pi_kp_high_spd_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw010_speed_pi_kp_high_spd_is_in_range(uint16_t value);

/**
 * Pack message RTW009_Iq_PI.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_rtw009_iq_pi_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_rtw009_iq_pi_t *src_p,
    size_t size);

/**
 * Unpack message RTW009_Iq_PI.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_rtw009_iq_pi_unpack(
    struct dbc_v08_1_rtw009_iq_pi_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RTW009_Iq_PI.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_rtw009_iq_pi_init(struct dbc_v08_1_rtw009_iq_pi_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dbc_v08_1_rtw009_iq_pi_ki_iq_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw009_iq_pi_ki_iq_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw009_iq_pi_ki_iq_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dbc_v08_1_rtw009_iq_pi_kp_iq_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw009_iq_pi_kp_iq_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw009_iq_pi_kp_iq_is_in_range(uint32_t value);

/**
 * Pack message RTW008_Id_PI.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_rtw008_id_pi_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_rtw008_id_pi_t *src_p,
    size_t size);

/**
 * Unpack message RTW008_Id_PI.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_rtw008_id_pi_unpack(
    struct dbc_v08_1_rtw008_id_pi_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RTW008_Id_PI.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_rtw008_id_pi_init(struct dbc_v08_1_rtw008_id_pi_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dbc_v08_1_rtw008_id_pi_ki_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw008_id_pi_ki_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw008_id_pi_ki_id_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dbc_v08_1_rtw008_id_pi_kp_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw008_id_pi_kp_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw008_id_pi_kp_id_is_in_range(uint32_t value);

/**
 * Pack message TRTCC003.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_trtcc003_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_trtcc003_t *src_p,
    size_t size);

/**
 * Unpack message TRTCC003.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_trtcc003_unpack(
    struct dbc_v08_1_trtcc003_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from TRTCC003.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_trtcc003_init(struct dbc_v08_1_trtcc003_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_trtcc003_flash_cmd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_trtcc003_flash_cmd_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_trtcc003_flash_cmd_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_trtcc003_start_stop_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_trtcc003_start_stop_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_trtcc003_start_stop_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_trtcc003_flash_sample_number_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_trtcc003_flash_sample_number_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_trtcc003_flash_sample_number_is_in_range(uint16_t value);

/**
 * Pack message TDTACK002.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_tdtack002_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_tdtack002_t *src_p,
    size_t size);

/**
 * Unpack message TDTACK002.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_tdtack002_unpack(
    struct dbc_v08_1_tdtack002_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from TDTACK002.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_tdtack002_init(struct dbc_v08_1_tdtack002_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_tdtack002_flash_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtack002_flash_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtack002_flash_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dbc_v08_1_tdtack002_flash_err_address_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_tdtack002_flash_err_address_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_tdtack002_flash_err_address_is_in_range(uint32_t value);

/**
 * Pack message TRTW002.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_trtw002_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_trtw002_t *src_p,
    size_t size);

/**
 * Unpack message TRTW002.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_trtw002_unpack(
    struct dbc_v08_1_trtw002_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from TRTW002.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_trtw002_init(struct dbc_v08_1_trtw002_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dbc_v08_1_trtw002_spd_test_cmd_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_trtw002_spd_test_cmd_max_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_trtw002_spd_test_cmd_max_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dbc_v08_1_trtw002_trq_test_cmd_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_trtw002_trq_test_cmd_max_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_trtw002_trq_test_cmd_max_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_trtw002_drive_cycle_repetition_number_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_trtw002_drive_cycle_repetition_number_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_trtw002_drive_cycle_repetition_number_is_in_range(uint16_t value);

/**
 * Pack message TRTW001.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_trtw001_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_trtw001_t *src_p,
    size_t size);

/**
 * Unpack message TRTW001.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_trtw001_unpack(
    struct dbc_v08_1_trtw001_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from TRTW001.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_trtw001_init(struct dbc_v08_1_trtw001_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dbc_v08_1_trtw001_spd_test_cmd_flash_factor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_trtw001_spd_test_cmd_flash_factor_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_trtw001_spd_test_cmd_flash_factor_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dbc_v08_1_trtw001_trq_test_cmd_flash_factor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_trtw001_trq_test_cmd_flash_factor_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_trtw001_trq_test_cmd_flash_factor_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dbc_v08_1_trtw001_relative_time_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_trtw001_relative_time_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_trtw001_relative_time_is_in_range(uint32_t value);

/**
 * Pack message DTCP005.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_dtcp005_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_dtcp005_t *src_p,
    size_t size);

/**
 * Unpack message DTCP005.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_dtcp005_unpack(
    struct dbc_v08_1_dtcp005_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DTCP005.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_dtcp005_init(struct dbc_v08_1_dtcp005_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dtcp005_spd_slewrate_positive_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp005_spd_slewrate_positive_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp005_spd_slewrate_positive_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtcp005_throt_volt_slewrate_positive_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp005_throt_volt_slewrate_positive_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp005_throt_volt_slewrate_positive_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dtcp005_spd_slewrate_negative_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp005_spd_slewrate_negative_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp005_spd_slewrate_negative_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtcp005_throt_volt_slewrate_negative_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp005_throt_volt_slewrate_negative_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp005_throt_volt_slewrate_negative_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dbc_v08_1_dtcp005_autotuning_offset_angle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp005_autotuning_offset_angle_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp005_autotuning_offset_angle_is_in_range(uint32_t value);

/**
 * Pack message DTACK001.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_dtack001_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_dtack001_t *src_p,
    size_t size);

/**
 * Unpack message DTACK001.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_dtack001_unpack(
    struct dbc_v08_1_dtack001_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DTACK001.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_dtack001_init(struct dbc_v08_1_dtack001_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dbc_v08_1_dtack001_autotuning_offset_angle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtack001_autotuning_offset_angle_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtack001_autotuning_offset_angle_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtack001_config_update_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtack001_config_update_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtack001_config_update_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtack001_autotuning_config_update_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtack001_autotuning_config_update_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtack001_autotuning_config_update_status_is_in_range(uint8_t value);

/**
 * Pack message RTCC004.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_rtcc004_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_rtcc004_t *src_p,
    size_t size);

/**
 * Unpack message RTCC004.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_rtcc004_unpack(
    struct dbc_v08_1_rtcc004_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RTCC004.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_rtcc004_init(struct dbc_v08_1_rtcc004_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_rtcc004_pc_mode_enable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtcc004_pc_mode_enable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtcc004_pc_mode_enable_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_rtcc004_config_update_enable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtcc004_config_update_enable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtcc004_config_update_enable_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_rtcc004_control_update_enable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtcc004_control_update_enable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtcc004_control_update_enable_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_rtcc004_user_access_level_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtcc004_user_access_level_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtcc004_user_access_level_is_in_range(uint8_t value);

/**
 * Pack message DTCP007.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_dtcp007_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_dtcp007_t *src_p,
    size_t size);

/**
 * Unpack message DTCP007.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_dtcp007_unpack(
    struct dbc_v08_1_dtcp007_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DTCP007.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_dtcp007_init(struct dbc_v08_1_dtcp007_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dbc_v08_1_dtcp007_serial_number_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp007_serial_number_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp007_serial_number_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dtcp007_sw_version_major_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp007_sw_version_major_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp007_sw_version_major_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtcp007_sw_version_minor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp007_sw_version_minor_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp007_sw_version_minor_is_in_range(uint8_t value);

/**
 * Pack message RTW007.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_rtw007_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_rtw007_t *src_p,
    size_t size);

/**
 * Unpack message RTW007.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_rtw007_unpack(
    struct dbc_v08_1_rtw007_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RTW007.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_rtw007_init(struct dbc_v08_1_rtw007_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dbc_v08_1_rtw007_serial_number_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw007_serial_number_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw007_serial_number_is_in_range(uint32_t value);

/**
 * Pack message RTCC003.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_rtcc003_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_rtcc003_t *src_p,
    size_t size);

/**
 * Unpack message RTCC003.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_rtcc003_unpack(
    struct dbc_v08_1_rtcc003_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RTCC003.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_rtcc003_init(struct dbc_v08_1_rtcc003_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_rtcc003_update_config_para_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtcc003_update_config_para_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtcc003_update_config_para_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_rtcc003_fetch_config_para_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtcc003_fetch_config_para_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtcc003_fetch_config_para_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_rtcc003_cc_para1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtcc003_cc_para1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtcc003_cc_para1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_rtcc003_cc_para2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtcc003_cc_para2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtcc003_cc_para2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_rtcc003_cc_para3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtcc003_cc_para3_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtcc003_cc_para3_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_rtcc003_cc_para4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtcc003_cc_para4_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtcc003_cc_para4_is_in_range(uint16_t value);

/**
 * Pack message RTDT001.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_rtdt001_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_rtdt001_t *src_p,
    size_t size);

/**
 * Unpack message RTDT001.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_rtdt001_unpack(
    struct dbc_v08_1_rtdt001_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RTDT001.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_rtdt001_init(struct dbc_v08_1_rtdt001_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_rtdt001_gui_connection_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtdt001_gui_connection_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtdt001_gui_connection_is_in_range(uint8_t value);

/**
 * Pack message DT009_B003.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_dt009_b003_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_dt009_b003_t *src_p,
    size_t size);

/**
 * Unpack message DT009_B003.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_dt009_b003_unpack(
    struct dbc_v08_1_dt009_b003_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DT009_B003.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_dt009_b003_init(struct dbc_v08_1_dt009_b003_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dt009_b003_ac_curr_mea_rms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt009_b003_ac_curr_mea_rms_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt009_b003_ac_curr_mea_rms_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dt009_b003_dc_curr_estd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt009_b003_dc_curr_estd_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt009_b003_dc_curr_estd_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dt009_b003_dc_bus_volt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt009_b003_dc_bus_volt_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt009_b003_dc_bus_volt_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dbc_v08_1_dt009_b003_mtr_spd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt009_b003_mtr_spd_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt009_b003_mtr_spd_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dt009_b003_throt_volt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt009_b003_throt_volt_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt009_b003_throt_volt_is_in_range(uint16_t value);

/**
 * Pack message RTW005.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_rtw005_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_rtw005_t *src_p,
    size_t size);

/**
 * Unpack message RTW005.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_rtw005_unpack(
    struct dbc_v08_1_rtw005_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RTW005.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_rtw005_init(struct dbc_v08_1_rtw005_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_rtw005_spd_slewrate_positive_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw005_spd_slewrate_positive_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw005_spd_slewrate_positive_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_rtw005_throt_volt_slewrate_positive_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw005_throt_volt_slewrate_positive_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw005_throt_volt_slewrate_positive_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_rtw005_spd_slewrate_negative_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw005_spd_slewrate_negative_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw005_spd_slewrate_negative_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_rtw005_throt_volt_slewrate_negative_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw005_throt_volt_slewrate_negative_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw005_throt_volt_slewrate_negative_is_in_range(uint8_t value);

/**
 * Pack message RTCC002.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_rtcc002_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_rtcc002_t *src_p,
    size_t size);

/**
 * Unpack message RTCC002.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_rtcc002_unpack(
    struct dbc_v08_1_rtcc002_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RTCC002.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_rtcc002_init(struct dbc_v08_1_rtcc002_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_rtcc002_fwd_rev_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtcc002_fwd_rev_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtcc002_fwd_rev_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_rtcc002_eco_boost_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtcc002_eco_boost_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtcc002_eco_boost_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_rtcc002_spd_percentage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtcc002_spd_percentage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtcc002_spd_percentage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dbc_v08_1_rtcc002_run_spd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtcc002_run_spd_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtcc002_run_spd_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_rtcc002_throt_percentage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtcc002_throt_percentage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtcc002_throt_percentage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_rtcc002_run_trq_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtcc002_run_trq_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtcc002_run_trq_is_in_range(uint16_t value);

/**
 * Pack message DTCP004.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_dtcp004_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_dtcp004_t *src_p,
    size_t size);

/**
 * Unpack message DTCP004.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_dtcp004_unpack(
    struct dbc_v08_1_dtcp004_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DTCP004.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_dtcp004_init(struct dbc_v08_1_dtcp004_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtcp004_throt_type_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp004_throt_type_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp004_throt_type_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtcp004_fnr_type_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp004_fnr_type_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp004_fnr_type_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtcp004_direc_of_fwd_rotation_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp004_direc_of_fwd_rotation_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp004_direc_of_fwd_rotation_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtcp004_start_avail_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp004_start_avail_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp004_start_avail_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtcp004_park_avail_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp004_park_avail_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp004_park_avail_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtcp004_charger_avail_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp004_charger_avail_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp004_charger_avail_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtcp004_cruise_avail_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp004_cruise_avail_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp004_cruise_avail_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtcp004_kill_avail_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp004_kill_avail_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp004_kill_avail_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtcp004_eco_boost_avail_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp004_eco_boost_avail_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp004_eco_boost_avail_is_in_range(uint8_t value);

/**
 * Pack message RTW004.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_rtw004_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_rtw004_t *src_p,
    size_t size);

/**
 * Unpack message RTW004.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_rtw004_unpack(
    struct dbc_v08_1_rtw004_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RTW004.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_rtw004_init(struct dbc_v08_1_rtw004_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_rtw004_throt_type_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw004_throt_type_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw004_throt_type_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_rtw004_fnr_type_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw004_fnr_type_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw004_fnr_type_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_rtw004_direc_of_fwd_rotation_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw004_direc_of_fwd_rotation_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw004_direc_of_fwd_rotation_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_rtw004_start_avail_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw004_start_avail_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw004_start_avail_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_rtw004_park_avail_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw004_park_avail_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw004_park_avail_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_rtw004_charger_avail_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw004_charger_avail_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw004_charger_avail_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_rtw004_cruise_avail_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw004_cruise_avail_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw004_cruise_avail_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_rtw004_kill_avail_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw004_kill_avail_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw004_kill_avail_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_rtw004_eco_boost_avail_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw004_eco_boost_avail_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw004_eco_boost_avail_is_in_range(uint8_t value);

/**
 * Pack message DTCP003.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_dtcp003_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_dtcp003_t *src_p,
    size_t size);

/**
 * Unpack message DTCP003.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_dtcp003_unpack(
    struct dbc_v08_1_dtcp003_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DTCP003.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_dtcp003_init(struct dbc_v08_1_dtcp003_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dtcp003_pwr_peak_eco_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp003_pwr_peak_eco_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp003_pwr_peak_eco_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dtcp003_mtr_temp_cutback_lmt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp003_mtr_temp_cutback_lmt_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp003_mtr_temp_cutback_lmt_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dtcp003_mtr_temp_cutoff_lmt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp003_mtr_temp_cutoff_lmt_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp003_mtr_temp_cutoff_lmt_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dtcp003_ctrlr_temp_cutback_lmt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp003_ctrlr_temp_cutback_lmt_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp003_ctrlr_temp_cutback_lmt_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dtcp003_ctrlr_temp_cutoff_lmt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp003_ctrlr_temp_cutoff_lmt_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp003_ctrlr_temp_cutoff_lmt_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtcp003_dcu_control_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp003_dcu_control_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp003_dcu_control_mode_is_in_range(uint8_t value);

/**
 * Pack message RTW003.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_rtw003_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_rtw003_t *src_p,
    size_t size);

/**
 * Unpack message RTW003.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_rtw003_unpack(
    struct dbc_v08_1_rtw003_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RTW003.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_rtw003_init(struct dbc_v08_1_rtw003_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_rtw003_pwr_peak_eco_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw003_pwr_peak_eco_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw003_pwr_peak_eco_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_rtw003_mtr_temp_cutback_lmt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw003_mtr_temp_cutback_lmt_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw003_mtr_temp_cutback_lmt_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_rtw003_mtr_temp_cutoff_lmt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw003_mtr_temp_cutoff_lmt_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw003_mtr_temp_cutoff_lmt_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_rtw003_ctrlr_temp_cutback_lmt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw003_ctrlr_temp_cutback_lmt_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw003_ctrlr_temp_cutback_lmt_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_rtw003_ctrlr_temp_cutoff_lmt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw003_ctrlr_temp_cutoff_lmt_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw003_ctrlr_temp_cutoff_lmt_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_rtw003_dcu_control_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw003_dcu_control_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw003_dcu_control_mode_is_in_range(uint8_t value);

/**
 * Pack message RTCC001.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_rtcc001_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_rtcc001_t *src_p,
    size_t size);

/**
 * Unpack message RTCC001.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_rtcc001_unpack(
    struct dbc_v08_1_rtcc001_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RTCC001.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_rtcc001_init(struct dbc_v08_1_rtcc001_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_rtcc001_snsr_health_trigg_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtcc001_snsr_health_trigg_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtcc001_snsr_health_trigg_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_rtcc001_start_stop_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtcc001_start_stop_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtcc001_start_stop_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_rtcc001_park_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtcc001_park_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtcc001_park_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_rtcc001_charger_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtcc001_charger_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtcc001_charger_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_rtcc001_cruise_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtcc001_cruise_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtcc001_cruise_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_rtcc001_kill_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtcc001_kill_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtcc001_kill_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_rtcc001_sw_rst_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtcc001_sw_rst_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtcc001_sw_rst_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_rtcc001_autotuning_cmd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtcc001_autotuning_cmd_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtcc001_autotuning_cmd_is_in_range(uint8_t value);

/**
 * Pack message DTFS001_Type.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_dtfs001_type_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_dtfs001_type_t *src_p,
    size_t size);

/**
 * Unpack message DTFS001_Type.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_dtfs001_type_unpack(
    struct dbc_v08_1_dtfs001_type_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DTFS001_Type.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_dtfs001_type_init(struct dbc_v08_1_dtfs001_type_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_can_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_can_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_can_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_ctrlr_temp_cutback_lmt_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_ctrlr_temp_cutback_lmt_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_ctrlr_temp_cutback_lmt_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_ctrlr_temp_cutoff_lmt_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_ctrlr_temp_cutoff_lmt_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_ctrlr_temp_cutoff_lmt_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_ctrlr_temp_snsr_oc_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_ctrlr_temp_snsr_oc_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_ctrlr_temp_snsr_oc_flt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_ctrlr_temp_snsr_sc_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_ctrlr_temp_snsr_sc_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_ctrlr_temp_snsr_sc_flt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_dc_bus_ov_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_dc_bus_ov_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_dc_bus_ov_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_dc_bus_snsr_oc_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_dc_bus_snsr_oc_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_dc_bus_snsr_oc_flt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_dc_bus_snsr_sc_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_dc_bus_snsr_sc_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_dc_bus_snsr_sc_flt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_dc_bus_uv_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_dc_bus_uv_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_dc_bus_uv_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_mtr_temp_cutback_lmt_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_mtr_temp_cutback_lmt_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_mtr_temp_cutback_lmt_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_mtr_temp_cutoff_lmt_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_mtr_temp_cutoff_lmt_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_mtr_temp_cutoff_lmt_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_mtr_temp_snsr_oc_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_mtr_temp_snsr_oc_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_mtr_temp_snsr_oc_flt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_mtr_temp_snsr_sc_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_mtr_temp_snsr_sc_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_mtr_temp_snsr_sc_flt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_ph_b_curr_snsr_oc_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_ph_b_curr_snsr_oc_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_ph_b_curr_snsr_oc_flt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_ph_b_curr_snsr_over_curr_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_ph_b_curr_snsr_over_curr_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_ph_b_curr_snsr_over_curr_flt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_ph_b_curr_snsr_sc_curr_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_ph_b_curr_snsr_sc_curr_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_ph_b_curr_snsr_sc_curr_flt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_ph_b_curr_snsr_sc_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_ph_b_curr_snsr_sc_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_ph_b_curr_snsr_sc_flt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_ph_c_curr_snsr_oc_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_ph_c_curr_snsr_oc_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_ph_c_curr_snsr_oc_flt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_ph_c_curr_snsr_over_curr_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_ph_c_curr_snsr_over_curr_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_ph_c_curr_snsr_over_curr_flt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_ph_c_curr_snsr_sc_curr_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_ph_c_curr_snsr_sc_curr_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_ph_c_curr_snsr_sc_curr_flt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_ph_c_curr_snsr_sc_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_ph_c_curr_snsr_sc_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_ph_c_curr_snsr_sc_flt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_qep_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_qep_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_qep_flt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_soc_low_lmt_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_soc_low_lmt_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_soc_low_lmt_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_throt_low_lmt_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_throt_low_lmt_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_throt_low_lmt_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_throt_redun_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_throt_redun_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_throt_redun_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_throt_stuck_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_throt_stuck_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_throt_stuck_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_throt_up_lmt_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_throt_up_lmt_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_throt_up_lmt_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_unexpected_park_sense_high_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_unexpected_park_sense_high_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_unexpected_park_sense_high_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_unintended_acceleration_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_unintended_acceleration_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_unintended_acceleration_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_unintended_deceleration_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_unintended_deceleration_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_unintended_deceleration_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_dc_bus_lv_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_dc_bus_lv_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_dc_bus_lv_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_throt_snsr_oc_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_throt_snsr_oc_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_throt_snsr_oc_flt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_throt_snsr_sc_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_throt_snsr_sc_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_throt_snsr_sc_flt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_fnr_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_fnr_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_fnr_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_fnr_warn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_fnr_warn_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_fnr_warn_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_supply12_snsr_oc_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_supply12_snsr_oc_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_supply12_snsr_oc_flt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_supply5_snsr_oc_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_supply5_snsr_oc_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_supply5_snsr_oc_flt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_supply12_uv_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_supply12_uv_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_supply12_uv_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_supply5_uv_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_supply5_uv_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_supply5_uv_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_hw_over_curr_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_hw_over_curr_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_hw_over_curr_flt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_type_0_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_type_0_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_type_0_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_type_1_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_type_1_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_type_1_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_type_2_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_type_2_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_type_2_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_type_3_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_type_3_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_type_3_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_type_4_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_type_4_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_type_4_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_qep_flt_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_qep_flt_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_qep_flt_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_ph_a_curr_snsr_over_curr_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_ph_a_curr_snsr_over_curr_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_ph_a_curr_snsr_over_curr_flt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtfs001_type_ph_a_curr_snsr_sc_curr_flt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtfs001_type_ph_a_curr_snsr_sc_curr_flt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtfs001_type_ph_a_curr_snsr_sc_curr_flt_is_in_range(uint8_t value);

/**
 * Pack message DTCP002.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_dtcp002_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_dtcp002_t *src_p,
    size_t size);

/**
 * Unpack message DTCP002.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_dtcp002_unpack(
    struct dbc_v08_1_dtcp002_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DTCP002.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_dtcp002_init(struct dbc_v08_1_dtcp002_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dbc_v08_1_dtcp002_spd_max_fwd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp002_spd_max_fwd_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp002_spd_max_fwd_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dtcp002_trq_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp002_trq_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp002_trq_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dbc_v08_1_dtcp002_spd_max_rev_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp002_spd_max_rev_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp002_spd_max_rev_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtcp002_throt_low_lmt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp002_throt_low_lmt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp002_throt_low_lmt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dtcp002_throt_up_lmt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp002_throt_up_lmt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp002_throt_up_lmt_is_in_range(uint8_t value);

/**
 * Pack message DTCP001.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_dtcp001_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_dtcp001_t *src_p,
    size_t size);

/**
 * Unpack message DTCP001.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_dtcp001_unpack(
    struct dbc_v08_1_dtcp001_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DTCP001.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_dtcp001_init(struct dbc_v08_1_dtcp001_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dtcp001_ac_curr_max_rms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp001_ac_curr_max_rms_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp001_ac_curr_max_rms_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dtcp001_dc_curr_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp001_dc_curr_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp001_dc_curr_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dtcp001_ov_lmt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp001_ov_lmt_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp001_ov_lmt_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dtcp001_uv_lmt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp001_uv_lmt_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp001_uv_lmt_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dtcp001_regen_curr_max_lmt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dtcp001_regen_curr_max_lmt_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dtcp001_regen_curr_max_lmt_is_in_range(uint16_t value);

/**
 * Pack message RTW002.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_rtw002_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_rtw002_t *src_p,
    size_t size);

/**
 * Unpack message RTW002.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_rtw002_unpack(
    struct dbc_v08_1_rtw002_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RTW002.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_rtw002_init(struct dbc_v08_1_rtw002_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dbc_v08_1_rtw002_spd_max_fwd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw002_spd_max_fwd_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw002_spd_max_fwd_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_rtw002_trq_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw002_trq_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw002_trq_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dbc_v08_1_rtw002_spd_max_rev_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw002_spd_max_rev_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw002_spd_max_rev_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_rtw002_throt_low_lmt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw002_throt_low_lmt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw002_throt_low_lmt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_rtw002_throt_up_lmt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw002_throt_up_lmt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw002_throt_up_lmt_is_in_range(uint8_t value);

/**
 * Pack message RTW001.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_rtw001_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_rtw001_t *src_p,
    size_t size);

/**
 * Unpack message RTW001.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_rtw001_unpack(
    struct dbc_v08_1_rtw001_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RTW001.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_rtw001_init(struct dbc_v08_1_rtw001_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_rtw001_ac_curr_max_rms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw001_ac_curr_max_rms_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw001_ac_curr_max_rms_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_rtw001_dc_curr_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw001_dc_curr_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw001_dc_curr_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_rtw001_ov_lmt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw001_ov_lmt_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw001_ov_lmt_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_rtw001_uv_lmt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw001_uv_lmt_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw001_uv_lmt_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_rtw001_regen_curr_max_lmt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_rtw001_regen_curr_max_lmt_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_rtw001_regen_curr_max_lmt_is_in_range(uint16_t value);

/**
 * Pack message DT008_B002.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_dt008_b002_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_dt008_b002_t *src_p,
    size_t size);

/**
 * Unpack message DT008_B002.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_dt008_b002_unpack(
    struct dbc_v08_1_dt008_b002_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DT008_B002.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_dt008_b002_init(struct dbc_v08_1_dt008_b002_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dt008_b002_ctrlr_temp1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt008_b002_ctrlr_temp1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt008_b002_ctrlr_temp1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dt008_b002_ctrlr_temp2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt008_b002_ctrlr_temp2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt008_b002_ctrlr_temp2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dt008_b002_ctrlr_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt008_b002_ctrlr_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt008_b002_ctrlr_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dt008_b002_mtr_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt008_b002_mtr_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt008_b002_mtr_temp_is_in_range(uint16_t value);

/**
 * Pack message DT007_B001_Status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_dt007_b001_status_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_dt007_b001_status_t *src_p,
    size_t size);

/**
 * Unpack message DT007_B001_Status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_dt007_b001_status_unpack(
    struct dbc_v08_1_dt007_b001_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DT007_B001_Status.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_dt007_b001_status_init(struct dbc_v08_1_dt007_b001_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dt007_b001_status_throt_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt007_b001_status_throt_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt007_b001_status_throt_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dt007_b001_status_eco_boost_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt007_b001_status_eco_boost_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt007_b001_status_eco_boost_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dt007_b001_status_limp_home_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt007_b001_status_limp_home_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt007_b001_status_limp_home_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dt007_b001_status_brake_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt007_b001_status_brake_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt007_b001_status_brake_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dt007_b001_status_forward_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt007_b001_status_forward_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt007_b001_status_forward_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dt007_b001_status_reverse_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt007_b001_status_reverse_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt007_b001_status_reverse_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dt007_b001_status_neutral_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt007_b001_status_neutral_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt007_b001_status_neutral_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dt007_b001_status_hillhold_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt007_b001_status_hillhold_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt007_b001_status_hillhold_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dt007_b001_status_regen_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt007_b001_status_regen_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt007_b001_status_regen_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dt007_b001_status_dcu_control_mode_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt007_b001_status_dcu_control_mode_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt007_b001_status_dcu_control_mode_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dt007_b001_status_asc_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt007_b001_status_asc_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt007_b001_status_asc_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dt007_b001_status_snsr_health_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt007_b001_status_snsr_health_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt007_b001_status_snsr_health_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dt007_b001_status_snsr_health_status_dc_bus_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt007_b001_status_snsr_health_status_dc_bus_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt007_b001_status_snsr_health_status_dc_bus_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dt007_b001_status_snsr_health_status12_v_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt007_b001_status_snsr_health_status12_v_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt007_b001_status_snsr_health_status12_v_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dt007_b001_status_snsr_health_status5_v_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt007_b001_status_snsr_health_status5_v_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt007_b001_status_snsr_health_status5_v_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dt007_b001_status_snsr_health_status_ph_b_curr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt007_b001_status_snsr_health_status_ph_b_curr_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt007_b001_status_snsr_health_status_ph_b_curr_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dt007_b001_status_snsr_health_status_ph_c_curr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt007_b001_status_snsr_health_status_ph_c_curr_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt007_b001_status_snsr_health_status_ph_c_curr_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dt007_b001_status_snsr_health_status_throt1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt007_b001_status_snsr_health_status_throt1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt007_b001_status_snsr_health_status_throt1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dt007_b001_status_snsr_health_status_throt2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt007_b001_status_snsr_health_status_throt2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt007_b001_status_snsr_health_status_throt2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dt007_b001_status_snsr_health_status_qep_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt007_b001_status_snsr_health_status_qep_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt007_b001_status_snsr_health_status_qep_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dt007_b001_status_snsr_health_status_mtr_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt007_b001_status_snsr_health_status_mtr_temp_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt007_b001_status_snsr_health_status_mtr_temp_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dt007_b001_status_snsr_health_status_ctlr_temp1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt007_b001_status_snsr_health_status_ctlr_temp1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt007_b001_status_snsr_health_status_ctlr_temp1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dt007_b001_status_snsr_health_status_ctlr_temp2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt007_b001_status_snsr_health_status_ctlr_temp2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt007_b001_status_snsr_health_status_ctlr_temp2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dt007_b001_status_pc_mode_enable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt007_b001_status_pc_mode_enable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt007_b001_status_pc_mode_enable_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dt007_b001_status_start_stop_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt007_b001_status_start_stop_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt007_b001_status_start_stop_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dt007_b001_status_idle_shutdown_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt007_b001_status_idle_shutdown_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt007_b001_status_idle_shutdown_is_in_range(uint8_t value);

/**
 * Pack message DT006_FOC006.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_dt006_foc006_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_dt006_foc006_t *src_p,
    size_t size);

/**
 * Unpack message DT006_FOC006.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_dt006_foc006_unpack(
    struct dbc_v08_1_dt006_foc006_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DT006_FOC006.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_dt006_foc006_init(struct dbc_v08_1_dt006_foc006_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dt006_foc006_throt_trq_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt006_foc006_throt_trq_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt006_foc006_throt_trq_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dt006_foc006_fw_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt006_foc006_fw_err_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt006_foc006_fw_err_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dbc_v08_1_dt006_foc006_spd_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt006_foc006_spd_err_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt006_foc006_spd_err_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dt006_foc006_pos_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt006_foc006_pos_err_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt006_foc006_pos_err_is_in_range(uint16_t value);

/**
 * Pack message DT005_FOC005.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_dt005_foc005_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_dt005_foc005_t *src_p,
    size_t size);

/**
 * Unpack message DT005_FOC005.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_dt005_foc005_unpack(
    struct dbc_v08_1_dt005_foc005_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DT005_FOC005.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_dt005_foc005_init(struct dbc_v08_1_dt005_foc005_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dt005_foc005_daxis_curr_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt005_foc005_daxis_curr_err_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt005_foc005_daxis_curr_err_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dt005_foc005_qaxis_curr_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt005_foc005_qaxis_curr_err_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt005_foc005_qaxis_curr_err_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dt005_foc005_dc_curr_clamp_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt005_foc005_dc_curr_clamp_err_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt005_foc005_dc_curr_clamp_err_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dbc_v08_1_dt005_foc005_mi_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt005_foc005_mi_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt005_foc005_mi_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dt005_foc005_dc_clamp_spd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt005_foc005_dc_clamp_spd_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt005_foc005_dc_clamp_spd_is_in_range(uint16_t value);

/**
 * Pack message DT004_FOC004.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_dt004_foc004_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_dt004_foc004_t *src_p,
    size_t size);

/**
 * Unpack message DT004_FOC004.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_dt004_foc004_unpack(
    struct dbc_v08_1_dt004_foc004_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DT004_FOC004.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_dt004_foc004_init(struct dbc_v08_1_dt004_foc004_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dt004_foc004_ph_a_curr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt004_foc004_ph_a_curr_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt004_foc004_ph_a_curr_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dt004_foc004_ph_b_curr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt004_foc004_ph_b_curr_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt004_foc004_ph_b_curr_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dt004_foc004_ph_c_curr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt004_foc004_ph_c_curr_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt004_foc004_ph_c_curr_is_in_range(uint16_t value);

/**
 * Pack message DT003_FOC003_DCCurrentModule.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_dt003_foc003_dc_current_module_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_dt003_foc003_dc_current_module_t *src_p,
    size_t size);

/**
 * Unpack message DT003_FOC003_DCCurrentModule.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_dt003_foc003_dc_current_module_unpack(
    struct dbc_v08_1_dt003_foc003_dc_current_module_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DT003_FOC003_DCCurrentModule.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_dt003_foc003_dc_current_module_init(struct dbc_v08_1_dt003_foc003_dc_current_module_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dt003_foc003_dc_current_module_daxis_curr_mea_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt003_foc003_dc_current_module_daxis_curr_mea_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt003_foc003_dc_current_module_daxis_curr_mea_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dt003_foc003_dc_current_module_qaxis_curr_mea_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt003_foc003_dc_current_module_qaxis_curr_mea_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt003_foc003_dc_current_module_qaxis_curr_mea_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dt003_foc003_dc_current_module_daxis_volt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt003_foc003_dc_current_module_daxis_volt_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt003_foc003_dc_current_module_daxis_volt_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dt003_foc003_dc_current_module_qaxis_volt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt003_foc003_dc_current_module_qaxis_volt_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt003_foc003_dc_current_module_qaxis_volt_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dt003_foc003_dc_current_module_daxis_curr_fw_ref_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt003_foc003_dc_current_module_daxis_curr_fw_ref_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt003_foc003_dc_current_module_daxis_curr_fw_ref_is_in_range(uint16_t value);

/**
 * Pack message DT002_FOC002_DQCurrentMeaRef.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_dt002_foc002_dq_current_mea_ref_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_dt002_foc002_dq_current_mea_ref_t *src_p,
    size_t size);

/**
 * Unpack message DT002_FOC002_DQCurrentMeaRef.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_dt002_foc002_dq_current_mea_ref_unpack(
    struct dbc_v08_1_dt002_foc002_dq_current_mea_ref_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DT002_FOC002_DQCurrentMeaRef.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_dt002_foc002_dq_current_mea_ref_init(struct dbc_v08_1_dt002_foc002_dq_current_mea_ref_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dt002_foc002_dq_current_mea_ref_daxis_curr_ref_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt002_foc002_dq_current_mea_ref_daxis_curr_ref_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt002_foc002_dq_current_mea_ref_daxis_curr_ref_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dt002_foc002_dq_current_mea_ref_daxis_curr_mea_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt002_foc002_dq_current_mea_ref_daxis_curr_mea_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt002_foc002_dq_current_mea_ref_daxis_curr_mea_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dt002_foc002_dq_current_mea_ref_qaxis_curr_ref_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt002_foc002_dq_current_mea_ref_qaxis_curr_ref_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt002_foc002_dq_current_mea_ref_qaxis_curr_ref_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dt002_foc002_dq_current_mea_ref_qaxis_curr_mea_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt002_foc002_dq_current_mea_ref_qaxis_curr_mea_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt002_foc002_dq_current_mea_ref_qaxis_curr_mea_is_in_range(uint16_t value);

/**
 * Pack message DT001_FOC001_SpeedTorqueRef.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dbc_v08_1_dt001_foc001_speed_torque_ref_pack(
    uint8_t *dst_p,
    const struct dbc_v08_1_dt001_foc001_speed_torque_ref_t *src_p,
    size_t size);

/**
 * Unpack message DT001_FOC001_SpeedTorqueRef.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dbc_v08_1_dt001_foc001_speed_torque_ref_unpack(
    struct dbc_v08_1_dt001_foc001_speed_torque_ref_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DT001_FOC001_SpeedTorqueRef.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dbc_v08_1_dt001_foc001_speed_torque_ref_init(struct dbc_v08_1_dt001_foc001_speed_torque_ref_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dbc_v08_1_dt001_foc001_speed_torque_ref_spd_ref_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt001_foc001_speed_torque_ref_spd_ref_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt001_foc001_speed_torque_ref_spd_ref_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dt001_foc001_speed_torque_ref_trq_ref_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt001_foc001_speed_torque_ref_trq_ref_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt001_foc001_speed_torque_ref_trq_ref_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dbc_v08_1_dt001_foc001_speed_torque_ref_dc_clamp_spd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dbc_v08_1_dt001_foc001_speed_torque_ref_dc_clamp_spd_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dbc_v08_1_dt001_foc001_speed_torque_ref_dc_clamp_spd_is_in_range(uint16_t value);


#ifdef __cplusplus
}
#endif

#endif
